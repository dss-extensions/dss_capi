// ************************************************************************ //
// WARNING
// -------
// This file is generated by the Type Library importer or Type Library Editor.
// Barring syntax errors, the Editor will parse modifications made to the file.
// However, when applying changes via the Editor this file will be regenerated
// and comments or formatting changes will be lost.
// ************************************************************************ //
// File generated on 2/26/2021 4:44:34 PM (- $Rev: 12980 $, 28540171).

[
  uuid(8BFDE413-245A-4514-B151-B16DCC243796),
  version(1.0),
  helpstring("OpenDSS Engine")

]
library OpenDSSengine
{

  importlib("stdole2.tlb");
  importlib("stdole32.tlb");

  interface IText;
  coclass Text;
  interface IDSSProperty;
  coclass DSSProperty;
  interface ICktElement;
  coclass CktElement;
  interface IError;
  coclass Error;
  interface ICircuit;
  coclass Circuit;
  interface IBus;
  coclass Bus;
  interface IDSS;
  coclass DSS;
  interface ISolution;
  coclass Solution;
  interface IMonitors;
  coclass Monitors;
  interface IMeters;
  coclass Meters;
  interface IGenerators;
  coclass Generators;
  interface IDSSProgress;
  coclass DSSProgress;
  interface ISettings;
  coclass Settings;
  interface ILines;
  coclass Lines;
  interface ICtrlQueue;
  coclass CtrlQueue;
  interface ILoads;
  coclass Loads;
  interface IDSSElement;
  coclass DSSElement;
  interface IActiveClass;
  coclass ActiveClass;
  interface ICapacitors;
  coclass Capacitors;
  interface ITransformers;
  interface ISwtControls;
  interface ICapControls;
  interface IRegControls;
  coclass Transformers;
  coclass SwtControls;
  coclass CapControls;
  coclass RegControls;
  interface ITopology;
  coclass Topology;
  interface IDSS_Executive;
  coclass DSS_Executive;
  interface IDSSEvents;
  dispinterface IDSSEventsEvents;
  coclass DSSEvents;
  interface ISensors;
  coclass Sensors;
  interface IXYCurves;
  coclass XYCurves;
  interface IPDElements;
  coclass PDElements;
  interface IReclosers;
  coclass Reclosers;
  interface IRelays;
  coclass Relays;
  interface ICmathLib;
  coclass CmathLib;
  interface IParser;
  coclass Parser;
  interface ILoadShapes;
  coclass LoadShapes;
  interface IFuses;
  coclass Fuses;
  interface IISources;
  coclass ISources;
  interface IDSSimComs;
  coclass DSSimComs;
  interface IPVSystems;
  coclass PVSystems;
  interface IVsources;
  coclass Vsources;
  interface IParallel;
  coclass Parallel;
  interface ILineCodes;
  coclass LineCodes;
  interface IGICSources;
  coclass GICSources;
  interface IReduceCkt;
  coclass ReduceCkt;


  [
    uuid(F694AF7D-DE1E-4CC2-8944-7D574FA06E3B),
    version(1.0),
    helpstring("Modes for Monitors\0for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum MonitorModes
  {
    [helpstring("Monitor records Voltage and Current at the terminal (Default)")]
    dssVI = 0,
    [helpstring("Monitor records kW, kvar or kVA, angle values, etc. at the terminal to which it is connected.")]
    dssPower = 1,
    [helpstring("Reports the monitored quantities as sequence quantities")]
    dssSequence = 16,
    [helpstring("Reports the monitored quantities in Magnitude Only")]
    dssMagnitude = 32,
    [helpstring("Reports the Positive Seq only or avg of all phases")]
    dssPosOnly = 64,
    [helpstring("For monitoring Regulator and Transformer taps")]
    dssTaps = 2,
    [helpstring("For monitoring State Variables (for PC Elements only)")]
    dssStates = 3
  };

  [
    uuid(421FFC54-1D6B-4900-B598-9E3E7E10FDD1),
    version(1.0),
    helpstring("\0\0des for Monitors\0for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum SolveModes
  {
    [helpstring("Solve a single snapshot power flow\0ses\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssSnapShot = 0,
    [helpstring("Solve following Duty Cycle load shapes\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssDutyCycle = 6,
    [helpstring("Solve direct (forced admittance model)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssDirect = 7,
    [helpstring("Solve following Daily load shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssDaily = 1,
    [helpstring("Monte Carlo Mode 1\0ly load shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMonte1 = 3,
    [helpstring("Monte Carlo Mode 2\0ly load shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMonte2 = 10,
    [helpstring("Monte Carlo Mode 3\0ly load shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMonte3 = 11,
    [helpstring("Fault study at all buses\0d shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssFaultStudy = 9,
    [helpstring("Solve following Yearly load shapes\0el)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssYearly = 2,
    [helpstring("Monte carlo Fault Study\0oad shapes\0el)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMonteFault = 8,
    [helpstring("Solves for Peak Day using Daily load curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssPeakDay = 5,
    [helpstring("Load-duration Mode 1\0sing Daily load curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssLD1 = 4,
    [helpstring("Load-Duration Mode 2\0sing Daily load curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssLD2 = 12,
    [helpstring("Auto add generators or capacitors\0ad curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssAutoAdd = 13,
    dssHarmonic = 15,
    dssDynamic = 14
  };

  [
    uuid(21B577B3-3F77-49B2-8F4D-A21BACDF6964),
    version(1.0),
    helpstring("\0\0des for Monitors\0for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum Options
  {
    [helpstring("Power Flow load model option\0tors\0ad curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssPowerFlow = 1,
    [helpstring("Admittance load model option\0tors\0ad curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssAdmittance = 2,
    [helpstring("Solution algorithm option - Normal solution mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssNormalSolve = 0,
    [helpstring("Solution algorithm option - Newton solution\0mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssNewtonSolve = 1,
    [helpstring("Control Mode option - Static\0ewton solution\0mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssStatic = 0,
    [helpstring("Control Mode Option - Event driven solution mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssEvent = 1,
    [helpstring("Control mode option - Time driven mode\0tion mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssTime = 2,
    [helpstring("Circuit model is multiphase (default)\0\0tion mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMultiphase = 0,
    [helpstring("Circuit model is positive sequence model only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssPositiveSeq = 1,
    [helpstring("Random mode = Gaussian\0ve sequence model only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssGaussian = 1,
    [helpstring("Random mode = Uniform\0\0ve sequence model only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssUniform = 2,
    [helpstring("Random Mode = Log normal\0 sequence model only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssLogNormal = 3,
    [helpstring("Add generators in AutoAdd mode (AddType)\0only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssAddGen = 1,
    [helpstring("Add capacitors in AutoAdd mode (Addtype)\0only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssAddCap = 2,
    [helpstring("Control Mode OFF = -1")]
    dssControlOFF = -1
  };

  [
    uuid(6DB3AE70-08E2-45D4-8E83-412C246F4C17),
    version(1.0),
    helpstring("\0\x01o\0d\0e\0C\0e\0n\0t\0r\0a\0l\0 \0E\0x\0a\0m\0p\0l\0e\0s\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum CapControlModes
  {
    [helpstring("voltage control, ON and OFF settings on the PT secondary base\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlVoltage = 1,
    [helpstring("kVAR control, ON and OFF settings on PT / CT base\0ondary base\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlKVAR = 2,
    [helpstring("Current control, ON and OFF settings on CT secondary\0ary base\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlCurrent = 0,
    [helpstring("ON and OFF settings are power factor, negative for leading\0se\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlPF = 4,
    [helpstring("Time control, ON and OFF settings are seconds from midnight\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlTime = 3
  };

  [
    uuid(CF246BDE-E2C7-4F1E-9227-A95F8F65F39F),
    version(1.0),
    helpstring("\0\x01o\0d\0e\0C\0e\0n\0t\0r\0a\0l\0 \0E\0x\0a\0m\0p\0l\0e\0s\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum ActionCodes
  {
    [helpstring("No action\0ol, ON and OFF settings are seconds from midnight\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionNone = 0,
    [helpstring("Open a switch\0ON and OFF settings are seconds from midnight\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionOpen = 1,
    [helpstring("Close a switch\0N and OFF settings are seconds from midnight\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionClose = 2,
    [helpstring("Reset to the shelf state (unlocked, closed for a switch)\0ht\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionReset = 3,
    [helpstring("Lock a switch, prventing both manual and automatic operation\0\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionLock = 4,
    [helpstring("Unlock a switch, permitting both manual and automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionUnlock = 5,
    [helpstring("Move a regulator tap up\0ing both manual and automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionTapUp = 6,
    [helpstring("Move a regulator tap down\0g both manual and automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionTapDown = 7
  };

  [
    uuid(A6526195-0103-45C1-B338-B9875F0B0A96)
  ]
  enum LoadStatus
  {
    dssLoadVariable = 0,
    dssLoadFixed = 1,
    dssLoadExempt = 2
  };

  [
    uuid(83BCFDCC-1FAF-4343-9930-2B6D02F6417D)
  ]
  enum LoadModels
  {
    dssLoadConstPQ = 1,
    dssLoadConstZ = 2,
    dssLoadMotor = 3,
    dssLoadCVR = 4,
    dssLoadConstI = 5,
    dssLoadConstPFixedQ = 6,
    dssLoadConstPFixedX = 7,
    dssLoadZIPV = 8
  };

  [
    uuid(9422E077-D357-4C87-BA49-C193788E755F)
  ]
  enum LineUnits
  {
    [helpstring("No line length unit.")]
    dssLineUnitsNone = 0,
    [helpstring("Line length units in miles.")]
    dssLineUnitsMiles = 1,
    [helpstring("Line length units are in thousand feet.")]
    dssLineUnitskFt = 2,
    [helpstring("Line length units are km.")]
    dssLineUnitskm = 3,
    [helpstring("Line length units are meters.")]
    dssLineUnitsmeter = 4,
    [helpstring("Line units in feet.")]
    dssLineUnitsft = 5,
    [helpstring("Line length units are inches.")]
    dssLineUnitsinch = 6,
    [helpstring("Line units are cm.")]
    dssLineUnitscm = 7,
    [helpstring("Line length units are mm.")]
    dssLineUnitsmm = 8,
    [helpstring("Maximum number of line units constants.")]
    dssLineUnitsMaxnum = 9
  };

  [
    uuid(0513A8DC-2C0D-4648-8BD7-2130B82C05FA),
    version(1.0),
    helpstring("Dispatch interface for Text Object\0\0e\0;\0p\x12\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IText: IDispatch
  {
    [propget, id(0x00000001), helpstring("Input command string for the DSS.\0ve Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Command([out, retval] BSTR* Command);
    [propput, id(0x00000001), helpstring("Input command string for the DSS.\0ve Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Command([in] BSTR Command);
    [propget, id(0x00000002), helpstring("Result string for the last command.\0 Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Result([out, retval] BSTR* Result);
  };

  [
    uuid(1298D126-0750-4B2A-8462-62EFE7310DF2),
    version(1.0),
    helpstring("Dispatch interface for DSSProperty Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IDSSProperty: IDispatch
  {
    [propget, id(0x00000001), helpstring("Name of Property\0 the last command.\0 Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Name);
    [propget, id(0x00000003), helpstring("Description of the property.\0mmand.\0 Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Description([out, retval] BSTR* Description);
    [propget, id(0x00000002)]
    HRESULT _stdcall Val([out, retval] BSTR* Value);
    [propput, id(0x00000002)]
    HRESULT _stdcall Val([in] BSTR Value);
  };

  [
    uuid(F20E8327-5B60-478E-8DBD-5EFC75EB929B),
    version(1.0),
    helpstring("Dispatch interface for CktElement Object\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface ICktElement: IDispatch
  {
    [propget, id(0x00000001), helpstring("Full Name of Active Circuit Element\0 Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propget, id(0x00000002), helpstring("Number of Terminals this Circuit Element\0ct\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumTerminals([out, retval] long* Value);
    [propget, id(0x00000003), helpstring("Number of Conductors per Terminal\0lement\0ct\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumConductors([out, retval] long* Value);
    [propget, id(0x00000004), helpstring("Number of Phases\0ors per Terminal\0lement\0ct\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumPhases([out, retval] long* Value);
    [propget, id(0x00000005), helpstring("Variant array of strings. Get  Bus definitions to which each terminal is connected. 0-based array.")]
    HRESULT _stdcall BusNames([out, retval] VARIANT* Value);
    [propput, id(0x00000005), helpstring("Variant array of strings. Set Bus definitions for each terminal is connected.\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall BusNames([in] VARIANT Value);
    [propget, id(0x00000006), helpstring("Collection of Properties for this Circuit Element (0 based index, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Properties([in] VARIANT Indx, [out, retval] IDSSProperty** Value);
    [propget, id(0x00000007), helpstring("Complex array of voltages at terminals\0it Element (0 based index, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Voltages([out, retval] VARIANT* Value);
    [propget, id(0x00000008), helpstring("Complex array of currents into each conductor of each terminal\0x, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Currents([out, retval] VARIANT* Value);
    [propget, id(0x00000009), helpstring("Complex array of powers into each conductor of each terminal\0l\0x, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Powers([out, retval] VARIANT* Value);
    [propget, id(0x0000000A), helpstring("Total losses in the element: two-element complex array\0minal\0l\0x, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Losses([out, retval] VARIANT* Value);
    [propget, id(0x0000000B), helpstring("Complex array of losses by phase\0element complex array\0minal\0l\0x, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PhaseLosses([out, retval] VARIANT* Value);
    [propget, id(0x0000000C), helpstring("Double array of symmetrical component voltages at each 3-phase terminal\0eric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SeqVoltages([out, retval] VARIANT* Value);
    [propget, id(0x0000000D), helpstring("Double array of symmetrical component currents into each 3-phase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SeqCurrents([out, retval] VARIANT* Value);
    [propget, id(0x0000000E), helpstring("Double array of sequence powers into each 3-phase teminal\0-phase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SeqPowers([out, retval] VARIANT* Value);
    [propget, id(0x0000000F), helpstring("Boolean indicating that element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Enabled([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x0000000F), helpstring("Boolean indicating that element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Enabled([in] VARIANT_BOOL Value);
    [propget, id(0x00000010), helpstring("Normal ampere rating for PD Elements")]
    HRESULT _stdcall NormalAmps([out, retval] double* Value);
    [propput, id(0x00000010), helpstring("Normal ampere rating\0at element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormalAmps([in] double Value);
    [propget, id(0x00000011), helpstring("Emergency Ampere Rating for PD elements")]
    HRESULT _stdcall EmergAmps([out, retval] double* Value);
    [propput, id(0x00000011), helpstring("Emergency Ampere Rating\0element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergAmps([in] double Value);
    [id(0x00000012), helpstring("Open the specified terminal and phase, if non-zero.  Else all conductors at terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Open([in] long Term, [in] long Phs);
    [id(0x00000013), helpstring("Close the specified terminal and phase, if non-zero.  Else all conductors at terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Close([in] long Term, [in] long Phs);
    [id(0x00000014), helpstring("Boolean indicating if the specified terminal and, optionally, phase is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsOpen([in] long Term, [in] long Phs, [out, retval] VARIANT_BOOL* Value);
    [propget, id(0x00000015), helpstring("Number of Properties this Circuit Element.\0l and, optionally, phase is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumProperties([out, retval] long* Value);
    [propget, id(0x00000016), helpstring("Variant array containing all property names of the active device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllPropertyNames([out, retval] VARIANT* Value);
    [propget, id(0x00000017), helpstring("Residual currents for each terminal: (mag, angle)\0 active device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Residuals([out, retval] VARIANT* Value);
    [propget, id(0x00000018), helpstring("YPrim matrix, column order, complex numbers (paired)\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Yprim([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("Display name of the object (not necessarily unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DisplayName([out, retval] BSTR* Value);
    [propput, id(0x000000C9), helpstring("Display name of the object (not necessarily unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DisplayName([in] BSTR Value);
    [propget, id(0x000000CA), helpstring("Pointer to this object\0ect (not necessarily unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Handle([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("globally unique identifier for this object\0 unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GUID([out, retval] BSTR* Value);
    [propget, id(0x000000CC), helpstring("This element has a SwtControl attached.\0ct\0 unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall HasSwitchControl([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000CD), helpstring("This element has a CapControl or RegControl attached.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall HasVoltControl([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000CE), helpstring("Name of the Energy Meter this element is assigned to.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EnergyMeter([out, retval] BSTR* Value);
    [propget, id(0x000000CF), helpstring("Full name of the i-th controller attached to this element. Ex: str = Controller(2).  See NumControls to determine valid index range")]
    HRESULT _stdcall Controller([in] long idx, [out, retval] BSTR* Value);
    [propget, id(0x000000D0), helpstring("Complex double array of Sequence Voltage for all terminals of active circuit element.")]
    HRESULT _stdcall CplxSeqVoltages([out, retval] VARIANT* Value);
    [propget, id(0x000000D1), helpstring("Complex double array of Sequence Currents for all conductors of all terminals of active circuit element.")]
    HRESULT _stdcall CplxSeqCurrents([out, retval] VARIANT* Value);
    [propget, id(0x000000D2), helpstring("Variant array of strings listing all the published variable names, if a PCElement. Otherwise, null string.")]
    HRESULT _stdcall AllVariableNames([out, retval] VARIANT* Value);
    [propget, id(0x000000D3), helpstring("Variant array of doubles. Values of state variables of active element if PC element.")]
    HRESULT _stdcall AllVariableValues([out, retval] VARIANT* Value);
    [propget, id(0x000000D4), helpstring("For PCElement, get the value of a variable by name. If Code>0 Then no variable by this name or not a PCelement.")]
    HRESULT _stdcall Variable([in] BSTR MyVarName, [out] long* Code, [out, retval] double* Value);
    [propget, id(0x000000D5), helpstring("For PCElement, get the value of a variable by integer index.")]
    HRESULT _stdcall Variablei([in] long Idx, [out] long* Code, [out, retval] double* Value);
    [propget, id(0x000000D6), helpstring("Variant array of integer containing the node numbers (representing phases, for example) for each conductor of each terminal. ")]
    HRESULT _stdcall NodeOrder([out, retval] VARIANT* Value);
    [propget, id(0x000000D7), helpstring("True if a recloser, relay, or fuse controlling this ckt element. OCP = Overcurrent Protection ")]
    HRESULT _stdcall HasOCPDevice([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000D8), helpstring("Number of controls connected to this device. Use to determine valid range for index into Controller array.")]
    HRESULT _stdcall NumControls([out, retval] long* Value);
    [propget, id(0x000000D9), helpstring("Index into Controller list of OCP Device controlling this CktElement")]
    HRESULT _stdcall OCPDevIndex([out, retval] long* Value);
    [propget, id(0x000000DA), helpstring("0=None; 1=Fuse; 2=Recloser; 3=Relay;  Type of OCP controller device")]
    HRESULT _stdcall OCPDevType([out, retval] long* Value);
    [propget, id(0x000000DB), helpstring("Currents in magnitude, angle format as a variant array of doubles.")]
    HRESULT _stdcall CurrentsMagAng([out, retval] VARIANT* Value);
    [propget, id(0x000000DC), helpstring("Voltages at each conductor in magnitude, angle form as variant array of doubles.")]
    HRESULT _stdcall VoltagesMagAng([out, retval] VARIANT* Value);
    [propget, id(0x000000DD), helpstring("Returns the total powers (complex) at ALL terminals of the active circuit element.")]
    HRESULT _stdcall TotalPowers([out, retval] VARIANT* Value);
  };

  [
    uuid(B521E339-8ED2-4BD6-9AEB-FD349CA8D8E3),
    version(1.0),
    helpstring("Dispatch interface for Errror Object\0ect\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IError: IDispatch
  {
    [propget, id(0x00000001), helpstring("Error Number\0the controller attached to this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Number([out, retval] long* Number);
    [propget, id(0x00000002), helpstring("Description of error for last operation\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Description([out, retval] BSTR* Description);
  };

  [
    uuid(32441C6D-7A27-4164-B5B0-FA054300C217),
    version(1.0),
    helpstring("Dispatch interface for Circuit Object\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface ICircuit: IDispatch
  {
    [propget, id(0x00000001), helpstring("Name of the active circuit.\0t operation\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propget, id(0x00000002), helpstring("Number of CktElements in the circuit.\0n\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumCktElements([out, retval] long* Value);
    [propget, id(0x00000003), helpstring("Total number of Buses in the circuit.\0n\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumBuses([out, retval] long* Value);
    [propget, id(0x00000004), helpstring("Total number of nodes in the circuit.\0n\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumNodes([out, retval] long* Value);
    [propget, id(0x00000005), helpstring("Collection of Buses in the circuit. Index may be string or integer index (0 based).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Buses([in] VARIANT Index, [out, retval] IBus** Value);
    [propget, id(0x00000006), helpstring("Collection of CktElements in Circuit\0ndex may be string or integer index (0 based).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CktElements([in] VARIANT Idx, [out, retval] ICktElement** Value);
    [propget, id(0x00000007), helpstring("Total losses in active circuit, complex number (two-element array of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Losses([out, retval] VARIANT* Value);
    [propget, id(0x00000008), helpstring("Complex total line losses in the circuit\0umber (two-element array of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LineLosses([out, retval] VARIANT* Value);
    [propget, id(0x00000009), helpstring("Complex losses in all transformers designated to substations.\0ray of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SubstationLosses([out, retval] VARIANT* Value);
    [propget, id(0x0000000A), helpstring("Total power, watts delivered to the circuit\0d to substations.\0ray of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TotalPower([out, retval] VARIANT* Value);
    [propget, id(0x0000000B), helpstring("Complex array of all bus, node voltages from most recent solution\0of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusVolts([out, retval] VARIANT* Value);
    [propget, id(0x0000000C), helpstring("Array of magnitudes (doubles) of voltages at all buses\0t solution\0of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusVmag([out, retval] VARIANT* Value);
    [propget, id(0x0000000D), helpstring("Vaiant array of strings containing Full Name of all elements.\0ion\0of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllElementNames([out, retval] VARIANT* Value);
    [propget, id(0x0000000E), helpstring("Return an interface to the active circuit element\0l elements.\0ion\0of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveElement([out, retval] ICktElement** Value);
    [id(0x0000000F), helpstring("Disable a circuit element by name (removes from circuit but leave in database)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Disable([in] BSTR Name);
    [id(0x00000010), helpstring("Activate (enable) a disabled device.\0moves from circuit but leave in database)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Enable([in] BSTR Name);
    [propget, id(0x00000011), helpstring("Return an interface to the Solution object.\0rom circuit but leave in database)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Solution([out, retval] ISolution** Value);
    [propget, id(0x00000012), helpstring("Return an interface to the active bus.\0ect.\0rom circuit but leave in database)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveBus([out, retval] IBus** Value);
    [id(0x00000013), helpstring("Sets the first Power Conversion (PC) element to be the active element.\0tabase)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall FirstPCElement([out, retval] long* Value);
    [id(0x00000014), helpstring("Gets next PC Element.  Returns 0 if no more.\0to be the active element.\0tabase)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NextPCElement([out, retval] long* Value);
    [id(0x00000015), helpstring("Sets the first Power Delivery (PD) element to be the active element.\0.\0tabase)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall FirstPDElement([out, retval] long* Value);
    [id(0x00000016), helpstring("Gets next PD Element. Returns 0 if no more.\0o be the active element.\0.\0tabase)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NextPDElement([out, retval] long* Value);
    [propget, id(0x00000017), helpstring("Array of strings containing names of all buses in circuit (see AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusNames([out, retval] VARIANT* Value);
    [propget, id(0x00000018), helpstring("Array of total losses (complex) in each circuit element\0t (see AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllElementLosses([out, retval] VARIANT* Value);
    [id(0x00000019), helpstring("Force all Meters and Monitors to take a sample.\0element\0t (see AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Sample(void);
    [id(0x0000001A), helpstring("Force all meters and monitors to save their current buffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SaveSample(void);
    [propget, id(0x0000001B), helpstring("Returns interface to Monitors collection.\0r current buffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Monitors([out, retval] IMonitors** Value);
    [propget, id(0x0000001C), helpstring("Returns interface to Meters (EnergyMeter) collection.\0ffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Meters([out, retval] IMeters** Value);
    [propget, id(0x0000001D), helpstring("Returns a Generators Object interface\0er) collection.\0ffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Generators([out, retval] IGenerators** Value);
    [propget, id(0x0000001E), helpstring("Returns interface to Settings interface.\0 collection.\0ffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Settings([out, retval] ISettings** Value);
    [propget, id(0x0000001F), helpstring("Returns Interface to Lines collection.\0.\0 collection.\0ffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Lines([out, retval] ILines** Value);
    [id(0x00000020), helpstring("Sets the Active Circuit Element using the full object name (e.g. \"generator.g1\"). Returns -1 if not found. Else index to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetActiveElement([in] BSTR FullName, [out, retval] long* Value);
    [id(0x00000021)]
    HRESULT _stdcall Capacity([in] double Start, [in] double Increment, [out, retval] double* Value);
    [id(0x00000022), helpstring("Sets Active bus by name. Ignores node list.  Returns bus index (zero based) compatible with AllBusNames and Buses collection.")]
    HRESULT _stdcall SetActiveBus([in] BSTR BusName, [out, retval] long* Value);
    [id(0x00000024), helpstring("Sets ActiveBus by Integer value.  0-based index compatible with SetActiveBus return value and AllBusNames indexing. Returns 0 if OK.")]
    HRESULT _stdcall SetActiveBusi([in] long BusIndex, [out, retval] long* Value);
    [propget, id(0x00000023), helpstring("Double Array of all bus voltages (each node) magnitudes in Per unit\0with AllBusNames and Buses collection.\0Else index to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusVmagPu([out, retval] VARIANT* Value);
    [propget, id(0x00000025), helpstring("Variant array of strings containing full name of each node in system in same order as returned by AllBusVolts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeNames([out, retval] VARIANT* Value);
    [propget, id(0x00000026), helpstring("System Y matrix (after a solution has been performed)\0node in system in same order as returned by AllBusVolts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SystemY([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("Interface to the main Control Queue\0s been performed)\0node in system in same order as returned by AllBusVolts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CtrlQueue([out, retval] ICtrlQueue** Value);
    [propget, id(0x000000CA), helpstring("Returns distance from each bus to parent EnergyMeter. Corresponds to sequence in AllBusNames.\0 by AllBusVolts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusDistances([out, retval] VARIANT* Value);
    [propget, id(0x000000CB), helpstring("Returns an array of distances from parent EnergyMeter for each Node. Corresponds to AllBusVMag sequence.\0olts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeDistances([out, retval] VARIANT* Value);
    [propget, id(0x000000CC), helpstring("Returns Array of doubles represent voltage magnitudes for nodes on the specified phase.\0usVMag sequence.\0olts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeVmagByPhase([in] long Phase, [out, retval] VARIANT* Value);
    [propget, id(0x000000CD), helpstring("Returns array of per unit voltage magnitudes for each node by phase\0he specified phase.\0usVMag sequence.\0olts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeVmagPUByPhase([in] long Phase, [out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("Returns an array of doubles representing the distances to parent EnergyMeter. Sequence of array corresponds to other node ByPhase properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeDistancesByPhase([in] long Phase, [out, retval] VARIANT* Value);
    [propget, id(0x000000CF), helpstring("Return variant array of strings of the node names for the By Phase criteria. Sequence corresponds to other ByPhase properties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeNamesByPhase([in] long Phase, [out, retval] VARIANT* Value);
    [propget, id(0x000000D0), helpstring("Returns interface to Load element interface\0names for the By Phase criteria. Sequence corresponds to other ByPhase properties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Loads([out, retval] ILoads** Value);
    [id(0x000000D1), helpstring("Sets First element of active class to be the Active element in the active circuit. Returns 0 if none.\0ther ByPhase properties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall FirstElement([out, retval] long* Value);
    [id(0x000000D2), helpstring("Sets the next element of the active class to be the active element in the active circuit. Returns 0 if no more elements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NextElement([out, retval] long* Value);
    [id(0x000000D3), helpstring("Sets the active class by name.  Use FirstElement, NextElement to iterate through the class. Returns -1 if fails.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetActiveClass([in] BSTR ClassName, [out, retval] long* Value);
    [propget, id(0x000000D4), helpstring("Returns Interface to the Active DSS object, which could be either a circuit element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveDSSElement([out, retval] IDSSElement** Value);
    [propget, id(0x000000D5), helpstring("Returns interface to the Active Circuit element (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveCktElement([out, retval] ICktElement** Value);
    [propget, id(0x000000D6), helpstring("Returns interface to active class.\0cuit element (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveClass([out, retval] IActiveClass** Value);
    [propget, id(0x000000D7), helpstring("Returns interface to Transformers collection\0nt (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Transformers([out, retval] ITransformers** Value);
    [propget, id(0x000000D8), helpstring("Returns interface to SwtControls collection.\0nt (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwtControls([out, retval] ISwtControls** Value);
    [propget, id(0x000000D9), helpstring("Returns interface to CapControls collection\0\0nt (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CapControls([out, retval] ICapControls** Value);
    [propget, id(0x000000DA), helpstring("Returns interfact to RegControls collection\0\0nt (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegControls([out, retval] IRegControls** Value);
    [propget, id(0x000000DB), helpstring("Interface to the active circuit's Capacitors collection.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capacitors([out, retval] ICapacitors** Value);
    [propget, id(0x000000DC), helpstring("Interface to the active circuit's topology object.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Topology([out, retval] ITopology** Value);
    [propget, id(0x000000DD), helpstring("Interface to Sensors in the Active Circuit.")]
    HRESULT _stdcall Sensors([out, retval] ISensors** Value);
    [id(0x000000DE), helpstring("Forces update to all storage classes. Typically done after a solution. Done automatically in intrinsic solution modes.")]
    HRESULT _stdcall UpdateStorage(void);
    [propget, id(0x000000DF), helpstring("Sets Parent PD element, if any, to be the active circuit element and returns index>0; Returns 0 if it fails or not applicable.")]
    HRESULT _stdcall ParentPDElement([out, retval] long* Value);
    [propget, id(0x000000E0), helpstring("Interface to XYCurves in active circuit.")]
    HRESULT _stdcall XYCurves([out, retval] IXYCurves** Value);
    [propget, id(0x000000E1), helpstring("Interface to PDElements collection")]
    HRESULT _stdcall PDElements([out, retval] IPDElements** Value);
    [propget, id(0x000000E2)]
    HRESULT _stdcall Reclosers([out, retval] IReclosers** Value);
    [propget, id(0x000000E3)]
    HRESULT _stdcall Relays([out, retval] IRelays** Value);
    [propget, id(0x000000E4), helpstring("Interface to OpenDSS Load shapes currently defined.")]
    HRESULT _stdcall LoadShapes([out, retval] ILoadShapes** Value);
    [propget, id(0x000000E5), helpstring("Return interface to Fuses ")]
    HRESULT _stdcall Fuses([out, retval] Fuses** Value);
    [propget, id(0x000000E6), helpstring("Interface to ISOURCE devices")]
    HRESULT _stdcall Isources([out, retval] IISources** Value);
    [propget, id(0x000000E7), helpstring("Complex array of actual node voltages in same order as SystemY matrix.")]
    HRESULT _stdcall YNodeVarray([out, retval] VARIANT* Value);
    [id(0x000000E8), helpstring("Calls EndOfTimeStepCleanup in SolutionAlgs")]
    HRESULT _stdcall EndOfTimeStepUpdate(void);
    [propget, id(0x000000E9)]
    HRESULT _stdcall DSSim_Coms([out, retval] IDSSimComs** Value);
    [propget, id(0x000000EA), helpstring("Variant array of strings containing the names of the nodes in the same order as the Y matrix")]
    HRESULT _stdcall YNodeOrder([out, retval] VARIANT* Value);
    [propget, id(0x000000EB), helpstring("Variant array of doubles containing complex injection currents for the present solution. Is is the \"I\" vector of I=YV")]
    HRESULT _stdcall YCurrents([out, retval] VARIANT* Value);
    [propget, id(0x000000EC), helpstring("Interface to PVSystems collection")]
    HRESULT _stdcall PVSystems([out, retval] IPVSystems** Value);
    [propget, id(0x000000ED), helpstring("Vsources object collection")]
    HRESULT _stdcall Vsources([out, retval] IVsources** Value);
    [propget, id(0x000000EE), helpstring("Delivers a handler for the Parallel Dispatch interface")]
    HRESULT _stdcall Parallel([out, retval] IParallel** Value);
    [propget, id(0x000000EF), helpstring("Access the Linecodes library in this circuit")]
    HRESULT _stdcall LineCodes([out, retval] ILineCodes** Value);
    [propget, id(0x000000F0), helpstring("Connect to GICSources Interface")]
    HRESULT _stdcall GICsources([out, retval] IGICSources** Value);
    [propget, id(0x000000F1), helpstring("Connect to the Circuit Reduction Interface")]
    HRESULT _stdcall ReduceCkt([out, retval] IReduceCkt** Value);
  };

  [
    uuid(E5B78C35-88F8-495F-8CD1-EBB5D90ED228),
    version(1.0),
    helpstring("Dispatch interface for Bus Object\0ect\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IBus: IDispatch
  {
    [propget, id(0x00000001), helpstring("Name of Bus\0 the active circuit's topology object.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Name);
    [propget, id(0x00000002), helpstring("Number of Nodes this bus.\0rcuit's topology object.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumNodes([out, retval] long* NumNodes);
    [propget, id(0x00000003), helpstring("Complex array of voltages at this bus.\0ogy object.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Voltages([out, retval] VARIANT* Voltages);
    [propget, id(0x00000004), helpstring("Double Array of sequence voltages at this bus.\0ct.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SeqVoltages([out, retval] VARIANT* SeqVoltages);
    [propget, id(0x00000005), helpstring("Integer Array of Node Numbers defined at the bus in same order as the voltages.")]
    HRESULT _stdcall Nodes([out, retval] VARIANT* Nodes);
    [propget, id(0x00000006), helpstring("Open circuit voltage; Complex array.\0 at the bus.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Voc([out, retval] VARIANT* Voc);
    [propget, id(0x00000007), helpstring("Short circuit currents at bus; Complex Array.\0us.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Isc([out, retval] VARIANT* Isc);
    [propget, id(0x00000008), helpstring("Complex Array of pu voltages at the bus.\0ray.\0us.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall puVoltages([out, retval] VARIANT* Value);
    [propget, id(0x00000009), helpstring("Base voltage at bus in kV\0es at the bus.\0ray.\0us.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kVBase([out, retval] double* Value);
    [propget, id(0x0000000A), helpstring("Complex array of Zsc matrix at bus. Column by column.\0n.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ZscMatrix([out, retval] VARIANT* Value);
    [propget, id(0x0000000B), helpstring("Complex Positive-Sequence short circuit impedance at bus..\0tiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Zsc1([out, retval] VARIANT* Value);
    [propget, id(0x0000000C), helpstring("Complex Zero-Sequence short circuit impedance at bus.\0us..\0tiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Zsc0([out, retval] VARIANT* Value);
    [id(0x0000000D), helpstring("Recomputes Zsc for active bus for present circuit configuration.\0ement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ZscRefresh([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x0000000E), helpstring("Complex array of Ysc matrix at bus. Column by column.\0iguration.\0ement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall YscMatrix([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("False=0 else True. Indicates whether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Coorddefined([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000CA), helpstring("X Coordinate for bus (double)\0hether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall x([out, retval] double* Value);
    [propput, id(0x000000CA), helpstring("X Coordinate for bus (double)\0hether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall x([in] double Value);
    [propget, id(0x000000CB), helpstring("Y coordinate for bus(double)\0\0hether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall y([out, retval] double* Value);
    [propput, id(0x000000CB), helpstring("Y coordinate for bus(double)\0\0hether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall y([in] double Value);
    [propget, id(0x000000CC), helpstring("Distance from energymeter (if non-zero)\0oordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Distance([out, retval] double* Value);
    [id(0x000000CD), helpstring("Returns a unique node number at the active bus to avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GetUniqueNodeNumber([in] long StartNumber, [out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Complex Double array of Sequence Voltages (0, 1, 2) at this Bus.")]
    HRESULT _stdcall CplxSeqVoltages([out, retval] VARIANT* Value);
    [propget, id(0x000000CF), helpstring("Accumulated failure rate downstream from this bus; faults per year")]
    HRESULT _stdcall Lambda([out, retval] double* Value);
    [propget, id(0x000000D0), helpstring("Number of interruptions this bus per year")]
    HRESULT _stdcall N_interrupts([out, retval] double* Value);
    [propget, id(0x000000D1), helpstring("Average interruption duration, hr.")]
    HRESULT _stdcall Int_Duration([out, retval] double* Value);
    [propget, id(0x000000D2), helpstring("Annual number of customer-interruptions from this bus")]
    HRESULT _stdcall Cust_Interrupts([out, retval] double* Value);
    [propget, id(0x000000D3), helpstring("Accumulated customer outage durations")]
    HRESULT _stdcall Cust_Duration([out, retval] double* Value);
    [propget, id(0x000000D4), helpstring("Total numbers of customers served downline from this bus")]
    HRESULT _stdcall N_Customers([out, retval] long* Value);
    [propget, id(0x000000D5), helpstring("For 2- and 3-phase buses, returns variant array of complex numbers represetin L-L voltages in volts. Returns -1.0 for 1-phase bus. If more than 3 phases, returns only first 3.")]
    HRESULT _stdcall VLL([out, retval] VARIANT* Value);
    [propget, id(0x000000D6), helpstring("Returns Complex array of pu L-L voltages for 2- and 3-phase buses. Returns -1.0 for 1-phase bus. If more than 3 phases, returns only 3 phases.")]
    HRESULT _stdcall puVLL([out, retval] VARIANT* Value);
    [propget, id(0x000000D7), helpstring("Variant Array of doubles containing voltages in Magnitude (VLN), angle (deg) ")]
    HRESULT _stdcall VMagAngle([out, retval] VARIANT* Value);
    [propget, id(0x000000D8), helpstring("Variant array of doubles containig voltage magnitude, angle pairs in per unit")]
    HRESULT _stdcall puVmagAngle([out, retval] VARIANT* Value);
    [propget, id(0x000000D9), helpstring("Total length of line downline from this bus, in miles. For recloser siting algorithm.")]
    HRESULT _stdcall TotalMiles([out, retval] double* Value);
    [propget, id(0x000000DA), helpstring("Integer ID of the feeder section in which this bus is located.")]
    HRESULT _stdcall SectionID([out, retval] long* Value);
    [propget, id(0x000000DB), helpstring("Variant Array of Strings: List of LINE elements connected to this bus. Complete name Line.xxxx")]
    HRESULT _stdcall LineList([out, retval] VARIANT* Value);
    [propget, id(0x000000DC), helpstring("Variant array of strings: Full Names of LOAD elelments connected to this bus.")]
    HRESULT _stdcall LoadList([out, retval] VARIANT* Value);
    [propget, id(0x000000DD), helpstring("Variant array of doubles (complex) containing the complete 012 Zsc matrix")]
    HRESULT _stdcall ZSC012Matrix([out, retval] VARIANT* Value);
    [propget, id(0x000000DE), helpstring("Sets the GIS latitude assigned to this bus")]
    HRESULT _stdcall Latitude([out, retval] double* Value);
    [propput, id(0x000000DE), helpstring("Delivers the GIS latitude assigned to this bus (if any)")]
    HRESULT _stdcall Latitude([in] double Value);
    [propget, id(0x000000DF), helpstring("Sets the longitude given to the active Bus ")]
    HRESULT _stdcall Longitude([out, retval] double* Value);
    [propput, id(0x000000DF), helpstring("Delivers the longitude assigned to the active Bus (if any)")]
    HRESULT _stdcall Longitude([in] double Value);
    [propget, id(0x000000E0), helpstring("Returns an array with the names of all PCE connected to the active bus")]
    HRESULT _stdcall AllPCEatBus([out, retval] VARIANT* Value);
    [propget, id(0x000000E1), helpstring("Returns an array with the names of all PDE connected to the active bus")]
    HRESULT _stdcall AllPDEatBus([out, retval] VARIANT* Value);
  };

  [
    uuid(14644AD0-4909-48FF-B624-24E8C38D1AED),
    version(1.0),
    helpstring("Dispatch interface for DSSMain Object\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IDSS: IDispatch
  {
    [propget, id(0x00000001), helpstring("Number of Circuits currently defined\0ctive bus to avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumCircuits([out, retval] long* Value);
    [propget, id(0x00000002), helpstring("Collection of Circuit objects\0efined\0ctive bus to avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Circuits([in] VARIANT Idx, [out, retval] ICircuit** Value);
    [propget, id(0x00000003), helpstring("Returns interface to the active circuit.\0e bus to avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveCircuit([out, retval] ICircuit** Value);
    [propget, id(0x00000004), helpstring("Returns the DSS Text (command-result) interface.\0 avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Text([out, retval] IText** Value);
    [propget, id(0x00000005), helpstring("Returns Error interface.\0mand-result) interface.\0 avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Error([out, retval] IError** Value);
    [id(0x00000006), helpstring("Make a new circuit and return interface to active circuit.\0e collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NewCircuit([in] BSTR Name, [out, retval] ICircuit** Value);
    [id(0x00000007), helpstring("Clears all circuit definitions.\0terface to active circuit.\0e collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ClearAll(void);
    [id(0x00000008), helpstring("Shows non-MDI child form of the Main DSS Edit Form\0ircuit.\0e collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ShowPanel(void);
    [id(0x00000009), helpstring("Validate the user and start the DSS. Returns TRUE if successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Start([in] long code, [out, retval] VARIANT_BOOL* Value);
    [propget, id(0x0000000A), helpstring("Get version string for the DSS.\0DSS. Returns TRUE if successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Version([out, retval] BSTR* Value);
    [propget, id(0x0000000B), helpstring("Gets interface to the DSS Progress Meter\0rns TRUE if successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DSSProgress([out, retval] IDSSProgress** Value);
    [propget, id(0x0000000C), helpstring("List of DSS intrinsic classes (names of the classes)\0successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Classes([out, retval] VARIANT* Value);
    [propget, id(0x0000000D), helpstring("List of user-defined classes\0 (names of the classes)\0successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UserClasses([out, retval] VARIANT* Value);
    [propget, id(0x0000000E), helpstring("Number of DSS intrinsic classes\0ames of the classes)\0successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumClasses([out, retval] long* Value);
    [propget, id(0x0000000F), helpstring("Number of user-defined classes\0\0ames of the classes)\0successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumUserClasses([out, retval] long* Value);
    [propget, id(0x00000011), helpstring("DSS Data File Path.  Default path for reports, etc. from DSS\0ul.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DataPath([out, retval] BSTR* Value);
    [propput, id(0x00000011), helpstring("DSS Data File Path.  Default path for reports, etc. from DSS\0ul.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DataPath([in] BSTR Value);
    [id(0x00000012), helpstring("Resets DSS Initialization for restarts, etc from applets\0DSS\0ul.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Reset(void);
    [propget, id(0x00000014), helpstring("Default is TRUE. Use this to set to FALSE; Cannot reset to TRUE;\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllowForms([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000014), helpstring("Default is TRUE. Use this to set to FALSE; Cannot reset to TRUE;\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllowForms([in] VARIANT_BOOL Value);
    [propget, id(0x000000C9), helpstring("Returns the path name for the default text editor.\0eset to TRUE;\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultEditor([out, retval] BSTR* Value);
    [propget, id(0x000000CA), helpstring("Returns interface to the active class.\0ext editor.\0eset to TRUE;\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveClass([out, retval] IActiveClass** Value);
    [id(0x000000CB), helpstring("Sets the Active DSS Class for use with ActiveClass interface. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetActiveClass([in] BSTR ClassName, [out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Interface to DSS Executive commands and options\0ss interface. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Executive([out, retval] IDSS_Executive** Value);
    [propget, id(0x000000CE), helpstring("Interface to the DSS Events")]
    HRESULT _stdcall Events([out, retval] IDSSEvents** Value);
    [propget, id(0x000000CC), helpstring("Returns an interface to the complex math library.")]
    HRESULT _stdcall CmathLib([out, retval] ICmathLib** Value);
    [propget, id(0x000000CF), helpstring("Returns interface to the OpenDSS Parser library for use by user-written programs.")]
    HRESULT _stdcall Parser([out, retval] IParser** Value);
    [propget, id(0x000000D0)]
    HRESULT _stdcall DSSim_Coms([out, retval] IDSSimComs** Value);
  };

  [
    uuid(F2332365-962A-4DF4-9D1E-218E0B0F2CEF),
    version(1.0),
    helpstring("Dispatch interface for Solution Object\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface ISolution: IDispatch
  {
    [id(0x00000001), helpstring("Execute solution for present solution mode.\0ons\0ss interface. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Solve(void);
    [propget, id(0x00000002), helpstring("Set present solution mode (by a text code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([out, retval] long* Mode);
    [propput, id(0x00000002), helpstring("Set present solution mode (by a text code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([in] long Mode);
    [propget, id(0x00000003), helpstring("Set the Frequency for next solution\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Frequency([out, retval] double* Frequency);
    [propput, id(0x00000003), helpstring("Set the Frequency for next solution\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Frequency([in] double Frequency);
    [propget, id(0x00000004), helpstring("Set Hour for time series solutions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Hour([out, retval] long* Hour);
    [propput, id(0x00000004), helpstring("Set Hour for time series solutions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Hour([in] long Hour);
    [propget, id(0x00000005), helpstring("Seconds from top of the hour.\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Seconds([out, retval] double* Seconds);
    [propput, id(0x00000005), helpstring("Seconds from top of the hour.\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Seconds([in] double Seconds);
    [propget, id(0x00000006), helpstring("Time step size in sec\0e hour.\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall StepSize([out, retval] double* StepSize);
    [propput, id(0x00000006), helpstring("Time step size in sec\0e hour.\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall StepSize([in] double StepSize);
    [propget, id(0x00000007), helpstring("Set year for planning studies\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Year([out, retval] long* Year);
    [propput, id(0x00000007), helpstring("Set year for planning studies\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Year([in] long Year);
    [propget, id(0x00000008), helpstring("Default load multiplier applied to all non-fixed loads\0p)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LoadMult([out, retval] double* LoadMult);
    [propput, id(0x00000008), helpstring("Default load multiplier applied to all non-fixed loads\0p)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LoadMult([in] double LoadMult);
    [propget, id(0x00000009), helpstring("Number of iterations taken for last solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Iterations([out, retval] long* Iterations);
    [propget, id(0x0000000A), helpstring("Max allowable iterations.\0 for last solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxIterations([out, retval] long* MaxIterations);
    [propput, id(0x0000000A), helpstring("Max allowable iterations.\0 for last solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxIterations([in] long MaxIterations);
    [propget, id(0x0000000B), helpstring("Solution convergence tolerance.\0ast solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Tolerance([out, retval] double* Tolerance);
    [propput, id(0x0000000B), helpstring("Solution convergence tolerance.\0ast solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Tolerance([in] double Tolerance);
    [propget, id(0x0000000C), helpstring("Number of solutions to perform for Monte Carlo and time series simulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Number([out, retval] long* Number);
    [propput, id(0x0000000C), helpstring("Number of solutions to perform for Monte Carlo and time series simulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Number([in] long Number);
    [propget, id(0x0000000D), helpstring("Randomization mode for random variables \"Gaussian\" or \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Random([out, retval] long* Random);
    [propput, id(0x0000000D), helpstring("Randomization mode for random variables \"Gaussian\" or \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Random([in] long Random);
    [propget, id(0x0000000E), helpstring("ID (text) of the present solution mode\0 \"Gaussian\" or \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ModeID([out, retval] BSTR* Value);
    [propget, id(0x0000000F), helpstring("Load Model: {dssPowerFlow (default) | dssAdmittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LoadModel([out, retval] long* Value);
    [propput, id(0x0000000F), helpstring("Load Model: {dssPowerFlow (default) | dssAdmittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LoadModel([in] long Value);
    [propget, id(0x00000010), helpstring("Load-Duration Curve name for LD modes\0dssAdmittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LDCurve([out, retval] BSTR* Value);
    [propput, id(0x00000010), helpstring("Load-Duration Curve name for LD modes\0dssAdmittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LDCurve([in] BSTR Value);
    [propget, id(0x00000011), helpstring("Percent default  annual load growth rate\0Admittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall pctGrowth([out, retval] double* Value);
    [propput, id(0x00000011), helpstring("Percent default  annual load growth rate\0Admittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall pctGrowth([in] double Value);
    [propget, id(0x00000012), helpstring("Type of device to add in AutoAdd Mode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AddType([out, retval] long* Value);
    [propput, id(0x00000012), helpstring("Type of device to add in AutoAdd Mode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AddType([in] long Value);
    [propget, id(0x00000013), helpstring("Generator kW for AutoAdd mode\0dd Mode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenkW([out, retval] double* Value);
    [propput, id(0x00000013), helpstring("Generator kW for AutoAdd mode\0dd Mode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenkW([in] double Value);
    [propget, id(0x00000014), helpstring("PF for generators in AutoAdd mode\0ode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenPF([out, retval] double* Value);
    [propput, id(0x00000014), helpstring("PF for generators in AutoAdd mode\0ode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenPF([in] double Value);
    [propget, id(0x00000015), helpstring("Capacitor kvar for adding capacitors in AutoAdd mode\0lt) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capkvar([out, retval] double* Value);
    [propput, id(0x00000015), helpstring("Capacitor kvar for adding capacitors in AutoAdd mode\0lt) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capkvar([in] double Value);
    [propget, id(0x00000016), helpstring("Base Solution algorithm: {dssNormalSolve | dssNewtonSolve}\0dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Algorithm([out, retval] long* Value);
    [propput, id(0x00000016), helpstring("Base Solution algorithm: {dssNormalSolve | dssNewtonSolve}\0dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Algorithm([in] long Value);
    [propget, id(0x00000017), helpstring("{dssStatic* | dssEvent | dssTime}  Modes for control devices\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlMode([out, retval] long* Value);
    [propput, id(0x00000017), helpstring("{dssStatic* | dssEvent | dssTime}  Modes for control devices\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlMode([in] long Value);
    [propget, id(0x00000018), helpstring("Default Multiplier applied to generators (like LoadMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenMult([out, retval] double* Value);
    [propput, id(0x00000018), helpstring("Default Multiplier applied to generators (like LoadMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenMult([in] double Value);
    [propget, id(0x00000019), helpstring("Default daily load shape (defaults to \"Default\")\0adMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultDaily([out, retval] BSTR* Value);
    [propput, id(0x00000019), helpstring("Default daily load shape (defaults to \"Default\")\0adMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultDaily([in] BSTR Value);
    [propget, id(0x0000001A), helpstring("Default Yearly load shape (defaults to \"Default\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultYearly([out, retval] BSTR* Value);
    [propput, id(0x0000001A), helpstring("Default Yearly load shape (defaults to \"Default\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultYearly([in] BSTR Value);
    [propget, id(0x0000001B), helpstring("Array of strings containing the Event Log\0fault\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EventLog([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("Hour as a double, including fractional part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall dblHour([out, retval] double* Value);
    [propput, id(0x000000C9), helpstring("Hour as a double, including fractional part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall dblHour([in] double Value);
    [propput, id(0x000000CA), helpstring("Set Stepsize in minutes\0ing fractional part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall StepsizeMin([in] double Param1);
    [propput, id(0x000000CB), helpstring("Set Stepsize in Hr\0utes\0ing fractional part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall StepsizeHr([in] double Param1);
    [propget, id(0x000000CC), helpstring("Value of the control iteration counter\0part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlIterations([out, retval] long* Value);
    [propput, id(0x000000CC), helpstring("Value of the control iteration counter\0part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlIterations([in] long Value);
    [propget, id(0x000000CD), helpstring("Maximum allowable control iterations\0r\0part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxControlIterations([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("Maximum allowable control iterations\0r\0part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxControlIterations([in] long Value);
    [id(0x000000CE), helpstring("Sample controls and then process the control queue for present control mode and dispatch control actions\0.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Sample_DoControlActions(void);
    [id(0x000000CF), helpstring("Executes status check on all fault objects defined in the circuit.\0rol mode and dispatch control actions\0.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CheckFaultStatus(void);
    [id(0x000000D0), helpstring("Execute the snapshot power flow routine in the DSS that solves at the present state with control actions\0.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolveSnap(void);
    [id(0x000000D1), helpstring("Executes a direct solution from the system Y matrix, ignoring compensation currents of loads, generators (includes Yprim only)\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolveDirect(void);
    [id(0x000000D2), helpstring("Solves using present power flow method. Iterative solution rather than direct solution.\0oads, generators (includes Yprim only)\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolvePflow(void);
    [id(0x000000D3), helpstring("Similar to SolveSnap except no control actions are checked or executed\0direct solution.\0oads, generators (includes Yprim only)\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolveNoControl(void);
    [id(0x000000D4), helpstring("Executes a power flow solution (SolveNoControl) plus executes a CheckControlActions that executes any pending control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolvePlusControl(void);
    [id(0x000000D5), helpstring("Initializes some variables for snap shot power flow. SolveSnap does this automatically.\0 executes any pending control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall InitSnap(void);
    [id(0x000000D6), helpstring("The normal process for sampling and executing Control Actions and Fault Status and rebuilds Y if necessary.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CheckControls(void);
    [id(0x000000D7), helpstring("Executes a sampling of all intrinsic control devices, which push control actions onto the control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SampleControlDevices(void);
    [id(0x000000D8), helpstring("Pops control actions off the control queue and dispatches to the proper control element\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DoControlActions(void);
    [id(0x000000D9), helpstring("Force building of the System Y matrix\0ueue and dispatches to the proper control element\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall BuildYMatrix([in] long BuildOption, [in] long AllocateVI);
    [propget, id(0x000000DA), helpstring("Flag that indicates if elements of the System Y have been changed by recent activity.\0t\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SystemYChanged([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000DB), helpstring("Flag to indicate whether the circuit solution converged\0n changed by recent activity.\0t\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Converged([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000DB), helpstring("Flag to indicate whether the circuit solution converged\0n changed by recent activity.\0t\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Converged([in] VARIANT_BOOL Value);
    [propget, id(0x000000DC), helpstring("Total iterations including control iterations for most recent solution.\0ent activity.\0t\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Totaliterations([out, retval] long* Value);
    [propget, id(0x000000DD), helpstring("Max number of iterations required to converge at any control iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MostIterationsDone([out, retval] long* Value);
    [propget, id(0x000000DE), helpstring("Flag indicating the control actions are done.")]
    HRESULT _stdcall ControlActionsDone([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000DE)]
    HRESULT _stdcall ControlActionsDone([in] VARIANT_BOOL Value);
    [id(0x000000DF), helpstring("Call Cleanup, sample monitors, and increment time at end of time step.")]
    HRESULT _stdcall FinishTimeStep(void);
    [id(0x000000E0), helpstring("Update storage, invcontrol, etc at end of time step")]
    HRESULT _stdcall Cleanup(void);
    [propget, id(0x000000E1), helpstring("Gets the accumulated time of the simulation")]
    HRESULT _stdcall Total_Time([out, retval] double* Value);
    [propput, id(0x000000E1), helpstring("Sets the Accumulated time of the simulation")]
    HRESULT _stdcall Total_Time([in] double Value);
    [propget, id(0x000000E2), helpstring("Gets the time required to perform the latest solution (Read only)")]
    HRESULT _stdcall Process_Time([out, retval] double* Value);
    [propget, id(0x000000E3), helpstring("Get the solution process time + sample time for time step")]
    HRESULT _stdcall Time_of_Step([out, retval] double* Value);
    [propget, id(0x000000E4), helpstring("Get/Set the Solution.IntervalHrs variable used for devices that integrate")]
    HRESULT _stdcall IntervalHrs([out, retval] double* Value);
    [propput, id(0x000000E4), helpstring("Get/Set the Solution.IntervalHrs variable for custom solution algorithms")]
    HRESULT _stdcall IntervalHrs([in] double Value);
    [id(0x000000E5), helpstring("Solves the circuits for all the Actors created")]
    HRESULT _stdcall SolveAll(void);
    [propget, id(0x000000E6)]
    HRESULT _stdcall IncMatrix([out, retval] VARIANT* Value);
    [propget, id(0x000000E7)]
    HRESULT _stdcall IncMatrixRows([out, retval] VARIANT* Value);
    [propget, id(0x000000E8)]
    HRESULT _stdcall IncMatrixCols([out, retval] VARIANT* Value);
    [propget, id(0x000000E9)]
    HRESULT _stdcall BusLevels([out, retval] VARIANT* Value);
    [propget, id(0x000000EA)]
    HRESULT _stdcall Laplacian([out, retval] VARIANT* Value);
    [propget, id(0x000000EB), helpstring("Minimum number of iterations required for a power flow solution.")]
    HRESULT _stdcall MinIterations([out, retval] long* Value);
    [propput, id(0x000000EB), helpstring("Mininum number of iterations required for a power flow solution.")]
    HRESULT _stdcall MinIterations([in] long Value);
  };

  [
    uuid(5C339E44-C583-445C-91D1-3B1E49CAD6B0),
    version(1.0),
    helpstring("Dispatch interface for Monitors Object\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IMonitors: IDispatch
  {
    [propget, id(0x00000002), helpstring("Array of all Monitor Names\0quired to converge at any control iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x00000003), helpstring("Sets the first Monitor active.  Returns 0 if no monitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x00000004), helpstring("Sets next monitor active.  Returns 0 if no more.\0onitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [id(0x00000005), helpstring("Resets active Monitor object.\0urns 0 if no more.\0onitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Reset(void);
    [id(0x00000006), helpstring("Resets all Monitor Objects\0t.\0urns 0 if no more.\0onitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ResetAll(void);
    [id(0x00000007), helpstring("Causes active Monitor to take a sample.\0no more.\0onitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Sample(void);
    [id(0x00000008), helpstring("Causes active monitor to save its current sample buffer to its monitor stream. Then you can access the Bytestream or channel data. Most standard solution modes do this automatically.")]
    HRESULT _stdcall Save(void);
    [id(0x00000009), helpstring("Converts monitor file to text and displays with text editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Show(void);
    [propget, id(0x0000000A), helpstring("Name of CSV file associated with active Monitor.\0ext editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall FileName([out, retval] BSTR* Value);
    [propget, id(0x0000000B), helpstring("Set Monitor mode (bitmask integer - see DSS Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([out, retval] long* Value);
    [propput, id(0x0000000B), helpstring("Set Monitor mode (bitmask integer - see DSS Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([in] long Value);
    [propget, id(0x00000001), helpstring("Sets the active Monitor object by name\0 DSS Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x00000001), helpstring("Sets the active Monitor object by name\0 DSS Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x0000000C), helpstring("Byte Array containing monitor stream values. Make sure a \"save\" is done first (standard solution modes do this automatically)")]
    HRESULT _stdcall ByteStream([out, retval] VARIANT* Value);
    [propget, id(0x0000000D), helpstring("Number of Samples in Monitor at Present\0ues\0Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SampleCount([out, retval] long* Value);
    [id(0x000000C9), helpstring("Causes all Monitors to take a sample of the present state\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SampleAll(void);
    [id(0x000000CA), helpstring("Save all Monitor buffers to their respective file streams.")]
    HRESULT _stdcall SaveAll(void);
    [propget, id(0x000000CB), helpstring("Number of Monitors\0 to take a sample of the present state\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [id(0x000000CC), helpstring("Post-process monitor samples taken so far, e.g., Pst for mode=4")]
    HRESULT _stdcall Process(void);
    [id(0x000000CD), helpstring("All monitors post-process the data taken so far.")]
    HRESULT _stdcall ProcessAll(void);
    [propget, id(0x000000CE), helpstring("Monitor File Version (integer)")]
    HRESULT _stdcall FileVersion([out, retval] long* Value);
    [propget, id(0x000000CF), helpstring("Size of each record in ByteStream (Integer). Same as NumChannels.")]
    HRESULT _stdcall RecordSize([out, retval] long* Value);
    [propget, id(0x000000D0), helpstring("Header string;  Variant array of strings containing Channel names")]
    HRESULT _stdcall Header([out, retval] VARIANT* Value);
    [propget, id(0x000000D1), helpstring("Variant array of doubles containgin time value in hours for time-sampled monitor values; Empty if frequency-sampled values for harmonics solution  (see dblFreq)")]
    HRESULT _stdcall dblHour([out, retval] VARIANT* Value);
    [propget, id(0x000000D2), helpstring("Variant array of doubles containing frequency values for harmonics mode solutions; Empty for time mode solutions (use dblHour)")]
    HRESULT _stdcall dblFreq([out, retval] VARIANT* Value);
    [propget, id(0x000000D3), helpstring("Variant array of doubles for the specified channel  (usage: MyArray = DSSMonitor.Channel(i)) A Save or SaveAll  should be executed first. Done automatically by most standard solution modes.")]
    HRESULT _stdcall Channel([in] long Index, [out, retval] VARIANT* Value);
    [propget, id(0x000000D4), helpstring("Number of Channels in the active Monitor")]
    HRESULT _stdcall NumChannels([out, retval] long* Value);
    [propget, id(0x000000D5), helpstring("Full object name of element being monitored.")]
    HRESULT _stdcall Element([out, retval] BSTR* Value);
    [propput, id(0x000000D5), helpstring("Full object name of element being monitored.")]
    HRESULT _stdcall Element([in] BSTR Value);
    [propget, id(0x000000D6), helpstring("Terminal number of element being monitored")]
    HRESULT _stdcall Terminal([out, retval] long* Value);
    [propput, id(0x000000D6), helpstring("Terminal number of element being monitored.")]
    HRESULT _stdcall Terminal([in] long Value);
  };

  [
    uuid(86705B6C-352A-47F8-A24B-78B750EC3859),
    version(1.0),
    helpstring("Dispatch interface for Meters Object\0t\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IMeters: IDispatch
  {
    [propget, id(0x00000002), helpstring("Array of all energy Meter names\0mple of the present state\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x00000003), helpstring("Set the first energy Meter active. Returns 0 if none.\0ate\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x00000004), helpstring("Sets the next energy Meter active.  Returns 0 if no more.\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x00000005), helpstring("Array of strings containing the names of the registers.\0.\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegisterNames([out, retval] VARIANT* Value);
    [propget, id(0x00000006), helpstring("Array of all the values contained in the Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegisterValues([out, retval] VARIANT* Value);
    [id(0x00000007), helpstring("Resets registers of active Meter.\0in the Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Reset(void);
    [id(0x00000008), helpstring("Resets registers of all Meter objects.\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ResetAll(void);
    [id(0x00000009), helpstring("Forces active Meter to take a sample.\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Sample(void);
    [id(0x0000000A), helpstring("Saves meter register values.\0 sample.\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Save(void);
    [propget, id(0x0000000C), helpstring("Get/Set the active meter  name.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x0000000C), helpstring("Set a meter to be active by name.\0le.\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x00000001), helpstring("Totals of all registers of all meters\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Totals([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("Array of doubles to set values of Peak Current property\0 for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Peakcurrent([out, retval] VARIANT* Value);
    [propput, id(0x000000C9), helpstring("Array of doubles to set values of Peak Current property\0 for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Peakcurrent([in] VARIANT Value);
    [propget, id(0x000000CA), helpstring("Set the magnitude of the real part of the Calculated Current (normally determined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CalcCurrent([out, retval] VARIANT* Value);
    [propput, id(0x000000CA), helpstring("Set the magnitude of the real part of the Calculated Current (normally determined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CalcCurrent([in] VARIANT Value);
    [propget, id(0x000000CB), helpstring("Array of doubles: set the phase allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllocFactors([out, retval] VARIANT* Value);
    [propput, id(0x000000CB), helpstring("Array of doubles: set the phase allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllocFactors([in] VARIANT Value);
    [propget, id(0x000000CC), helpstring("Set Name of metered element\0ase allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MeteredElement([out, retval] BSTR* Value);
    [propput, id(0x000000CC), helpstring("Set Name of metered element\0ase allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MeteredElement([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("set Number of Metered Terminal\0 allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MeteredTerminal([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("set Number of Metered Terminal\0 allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MeteredTerminal([in] long Value);
    [propget, id(0x000000CE), helpstring("Global Flag in the DSS to indicate if Demand Interval (DI) files have been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DIFilesAreOpen([out, retval] VARIANT_BOOL* Value);
    [id(0x000000CF), helpstring("Causes all EnergyMeter objects to take a sample at the present time\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SampleAll(void);
    [id(0x000000D0), helpstring("Save All EnergyMeter objects\0s to take a sample at the present time\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SaveAll(void);
    [id(0x000000D1), helpstring("Open Demand Interval (DI) files\0o take a sample at the present time\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall OpenAllDIFiles(void);
    [id(0x000000D2), helpstring("Close All Demand Interval Files ( Necessary at the end of a run)\0me\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CloseAllDIFiles(void);
    [propget, id(0x000000D3), helpstring("Number of zone end elements in the active meter zone.\0 of a run)\0me\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CountEndElements([out, retval] long* Value);
    [propget, id(0x000000D4), helpstring("Variant array of names of all zone end elements.\0one.\0 of a run)\0me\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllEndElements([out, retval] VARIANT* Value);
    [propget, id(0x000000D5), helpstring("Number of Energy Meters in the Active Circuit\0s.\0one.\0 of a run)\0me\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000D6), helpstring("Wide string list of all branches in zone of the active energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBranchesInZone([out, retval] VARIANT* Value);
    [propget, id(0x000000D7), helpstring("Number of branches in Active energymeter zone. (Same as sequencelist size)")]
    HRESULT _stdcall CountBranches([out, retval] long* Value);
    [propget, id(0x000000D8), helpstring("Returns SAIFI for this meter's Zone. Execute Reliability Calc method first.")]
    HRESULT _stdcall SAIFI([out, retval] double* Value);
    [propget, id(0x000000D9), helpstring("Get/set Index into Meter's SequenceList that contains branch pointers in lexical order. Earlier index guaranteed to be upline from later index. Sets PDelement active.")]
    HRESULT _stdcall SequenceIndex([out, retval] long* Value);
    [propput, id(0x000000D9), helpstring("Get/set Index into Meter's SequenceList that contains branch pointers in lexical order. Earlier index guaranteed to be upline from later index. Sets PDelement active.")]
    HRESULT _stdcall SequenceIndex([in] long Value);
    [propget, id(0x000000DA), helpstring("SAIFI based on kW rather than number of customers. Get after reliability calcs.")]
    HRESULT _stdcall SAIFIKW([out, retval] double* Value);
    [id(0x000000DB), helpstring("Calculate SAIFI, etc.")]
    HRESULT _stdcall DoReliabilityCalc([in] VARIANT_BOOL AssumeRestoration);
    [propget, id(0x000000DC), helpstring("Size of Sequence List")]
    HRESULT _stdcall SeqListSize([out, retval] long* Value);
    [propget, id(0x000000DD), helpstring("Total Number of customers in this zone (downline from the EnergyMeter)")]
    HRESULT _stdcall TotalCustomers([out, retval] long* Value);
    [propget, id(0x000000DE), helpstring("SAIDI for this meter's zone. Execute DoReliabilityCalc first.")]
    HRESULT _stdcall SAIDI([out, retval] double* Value);
    [propget, id(0x000000DF), helpstring("Total customer interruptions for this Meter zone based on reliability calcs.")]
    HRESULT _stdcall CustInterrupts([out, retval] double* Value);
    [propget, id(0x000000E0), helpstring("Number of feeder sections in this meter's zone")]
    HRESULT _stdcall NumSections([out, retval] long* Value);
    [id(0x000000E1), helpstring("Sets the designated section active if the index is valiid.")]
    HRESULT _stdcall SetActiveSection([in] long SectIdx);
    [propget, id(0x000000E2), helpstring("Type of OCP device. 1=Fuse; 2=Recloser; 3=Relay")]
    HRESULT _stdcall OCPDeviceType([out, retval] long* Value);
    [propget, id(0x000000E3), helpstring("Number of Customers in the active section.")]
    HRESULT _stdcall NumSectionCustomers([out, retval] long* Value);
    [propget, id(0x000000E4), helpstring("Number of branches (lines) in this section")]
    HRESULT _stdcall NumSectionBranches([out, retval] long* Value);
    [propget, id(0x000000E5), helpstring("Average Repair time in this section of the meter zone")]
    HRESULT _stdcall AvgRepairTime([out, retval] double* Value);
    [propget, id(0x000000E6), helpstring("Sum of Fault Rate time Repair Hrs in this section of the meter zone")]
    HRESULT _stdcall FaultRateXRepairHrs([out, retval] double* Value);
    [propget, id(0x000000E7), helpstring("Sum of the branch fault rates in this section of the meter's zone")]
    HRESULT _stdcall SumBranchFltRates([out, retval] double* Value);
    [propget, id(0x000000E8), helpstring("SequenceIndex of the branch at the head of this section")]
    HRESULT _stdcall SectSeqIdx([out, retval] long* Value);
    [propget, id(0x000000E9), helpstring("Total Customers downline from this section")]
    HRESULT _stdcall SectTotalCust([out, retval] long* Value);
    [propget, id(0x000000EA), helpstring("Returns the list of all PCE within the area covered by the EM")]
    HRESULT _stdcall ZonePCE([out, retval] VARIANT* Value);
  };

  [
    uuid(2D9B7548-D03E-478A-9FEA-9FC4033C793E),
    version(1.0),
    helpstring("Dispatch interface for Generators Object\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IGenerators: IDispatch
  {
    [propget, id(0x00000002), helpstring("Array of names of all Generator objects.\0zone.\0 active energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x00000003), helpstring("Array of Names of all generator energy meter registers\0energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegisterNames([out, retval] VARIANT* Value);
    [propget, id(0x00000004), helpstring("Array of valus in generator energy meter registers.\0rs\0energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegisterValues([out, retval] VARIANT* Value);
    [propget, id(0x00000005), helpstring("Sets first Generator to be active.  Returns 0 if none.\0energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x00000006), helpstring("Sets next Generator to be active.  Returns 0 if no more.\0ergymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x00000008), helpstring("Indicates whether the generator is forced ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForcedON([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000008), helpstring("Indicates whether the generator is forced ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForcedON([in] VARIANT_BOOL Value);
    [propget, id(0x00000009), helpstring("Sets a generator active by name.\0s forced ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x00000009), helpstring("Sets a generator active by name.\0s forced ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000C9), helpstring("Voltage base for the active generator, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([out, retval] double* Value);
    [propput, id(0x000000C9), helpstring("Voltage base for the active generator, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([in] double Value);
    [propget, id(0x000000CA), helpstring("kW output for the active generator. kvar is updated for current power factor.")]
    HRESULT _stdcall kW([out, retval] double* Value);
    [propput, id(0x000000CA), helpstring("kW output for the active generator. kvar is updated for current power factor")]
    HRESULT _stdcall kW([in] double Value);
    [propget, id(0x000000CB), helpstring("kvar output for the active generator. Updates power factor based on present kW value.")]
    HRESULT _stdcall kvar([out, retval] double* Value);
    [propput, id(0x000000CB), helpstring("kvar output for the active generator. Updates power factor based on present kW.")]
    HRESULT _stdcall kvar([in] double Value);
    [propget, id(0x000000CC), helpstring("Power factor (pos. = producing vars). Updates kvar based on present kW value.")]
    HRESULT _stdcall PF([out, retval] double* Value);
    [propput, id(0x000000CC), helpstring("Power factor (pos. = producing vars). Updates kvar based on present kW value.")]
    HRESULT _stdcall PF([in] double Value);
    [propget, id(0x000000CD), helpstring("Number of phases\0. = producing vars)\0, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Phases([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("Number of phases\0. = producing vars)\0, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Phases([in] long Value);
    [propget, id(0x000000CE), helpstring("Number of Generator Objects in Active Circuit\0egardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CF), helpstring("Get/Set active Generator by index into generators list.  1..Count")]
    HRESULT _stdcall idx([out, retval] long* Value);
    [propput, id(0x000000CF), helpstring("Get/Set active Generator by index into generators list. 1..Count")]
    HRESULT _stdcall idx([in] long Value);
    [propget, id(0x000000D0), helpstring("Generator Model")]
    HRESULT _stdcall Model([out, retval] long* Value);
    [propput, id(0x000000D0), helpstring("Generator Model")]
    HRESULT _stdcall Model([in] long Value);
    [propget, id(0x000000D1), helpstring("kVA rating of the generator")]
    HRESULT _stdcall kVArated([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("KVA Rating of the generator")]
    HRESULT _stdcall kVArated([in] double Value);
    [propget, id(0x000000D2), helpstring("vmaxpu for Generator model")]
    HRESULT _stdcall Vmaxpu([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("Vmaxpu for generator model")]
    HRESULT _stdcall Vmaxpu([in] double Value);
    [propget, id(0x000000D3), helpstring("Vminpu for Generator model")]
    HRESULT _stdcall Vminpu([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Vminpu for Generator model")]
    HRESULT _stdcall Vminpu([in] double Value);
  };

  [
    uuid(315C0C38-929C-4942-BDF8-6DA12D001B47),
    version(1.0),
    helpstring("Dispatch interface for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IDSSProgress: IDispatch
  {
    [propput, id(0x00000001), helpstring("Percent progress to indicate [0..100]\0Circuit\0egardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PctProgress([in] long Param1);
    [propput, id(0x00000002), helpstring("Caption to appear on the bottom of the DSS Progress form.\0other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Caption([in] BSTR Param1);
    [id(0x00000003), helpstring("Shows progress form with null caption and progress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Show(void);
    [id(0x00000004), helpstring("Closes (hides) DSS Progress form.\0ion and progress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Close(void);
  };

  [
    uuid(4E3928A0-8B75-4127-885F-F4AD6B3F4323),
    version(1.0),
    helpstring("Dispatch interface for Settings Object\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ISettings: IDispatch
  {
    [propget, id(0x00000001), helpstring("{True | False*} Designates whether to allow duplicate names of objects\0h criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllowDuplicates([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000001), helpstring("{True | False*} Designates whether to allow duplicate names of objects\0h criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllowDuplicates([in] VARIANT_BOOL Value);
    [propget, id(0x00000002), helpstring("{True | False*}  Locks Zones on energy meters to prevent rebuilding if a circuit change occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ZoneLock([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000002), helpstring("{True | False*}  Locks Zones on energy meters to prevent rebuilding if a circuit change occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ZoneLock([in] VARIANT_BOOL Value);
    [propput, id(0x00000003), helpstring("Sets all load allocation factors for all loads defined by XFKVA property to this value.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllocationFactors([in] double Param1);
    [propget, id(0x00000004), helpstring("List of Buses or (File=xxxx) syntax for the AutoAdd solution mode.\0perty to this value.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AutoBusList([out, retval] BSTR* Value);
    [propput, id(0x00000004), helpstring("List of Buses or (File=xxxx) syntax for the AutoAdd solution mode.\0perty to this value.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AutoBusList([in] BSTR Value);
    [propget, id(0x00000005), helpstring("{dssMultiphase * | dssPositiveSeq} IIndicate if the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CktModel([out, retval] long* Value);
    [propput, id(0x00000005), helpstring("{dssMultiphase * | dssPositiveSeq} IIndicate if the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CktModel([in] long Value);
    [propget, id(0x00000006), helpstring("Per Unit minimum voltage for Normal conditions.\0the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormVminpu([out, retval] double* Value);
    [propput, id(0x00000006), helpstring("Per Unit minimum voltage for Normal conditions.\0the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormVminpu([in] double Value);
    [propget, id(0x00000007), helpstring("Per Unit maximum voltage for Normal conditions.\0the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormVmaxpu([out, retval] double* Value);
    [propput, id(0x00000007), helpstring("Per Unit maximum voltage for Normal conditions.\0the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormVmaxpu([in] double Value);
    [propget, id(0x00000008), helpstring("Per Unit minimum voltage for Emergency conditions.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergVminpu([out, retval] double* Value);
    [propput, id(0x00000008), helpstring("Per Unit minimum voltage for Emergency conditions.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergVminpu([in] double Value);
    [propget, id(0x00000009), helpstring("Per Unit maximum voltage for Emergency conditions.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergVmaxpu([out, retval] double* Value);
    [propput, id(0x00000009), helpstring("Per Unit maximum voltage for Emergency conditions.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergVmaxpu([in] double Value);
    [propget, id(0x0000000A), helpstring("Weighting factor applied to UE register values.\0s.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UEweight([out, retval] double* Value);
    [propput, id(0x0000000A), helpstring("Weighting factor applied to UE register values.\0s.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UEweight([in] double Value);
    [propget, id(0x0000000B), helpstring("Weighting factor applied to Loss register values.\0\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LossWeight([out, retval] double* Value);
    [propput, id(0x0000000B), helpstring("Weighting factor applied to Loss register values.\0\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LossWeight([in] double Value);
    [propget, id(0x0000000C), helpstring("Array of Integers defining energy meter registers to use for computing UE\0ive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UEregs([out, retval] VARIANT* Value);
    [propput, id(0x0000000C), helpstring("Array of Integers defining energy meter registers to use for computing UE\0ive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UEregs([in] VARIANT Value);
    [propget, id(0x0000000D), helpstring("Integer array defining which energy meter registers to use for computing losses\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LossRegs([out, retval] VARIANT* Value);
    [propput, id(0x0000000D), helpstring("Integer array defining which energy meter registers to use for computing losses\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LossRegs([in] VARIANT Value);
    [propget, id(0x0000000E), helpstring("{True | False *} Gets value of trapezoidal integration flag in energy meters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Trapezoidal([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x0000000E), helpstring("{True | False *} Gets value of trapezoidal integration flag in energy meters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Trapezoidal([in] VARIANT_BOOL Value);
    [propget, id(0x0000000F), helpstring("Array of doubles defining the legal voltage bases in kV L-L\0in energy meters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall VoltageBases([out, retval] VARIANT* Value);
    [propput, id(0x0000000F), helpstring("Array of doubles defining the legal voltage bases in kV L-L\0in energy meters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall VoltageBases([in] VARIANT Value);
    [propget, id(0x00000010), helpstring("{True | False*} Denotes whether to trace the control actions to a file.\0ters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlTrace([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000010), helpstring("{True | False*} Denotes whether to trace the control actions to a file.\0ters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlTrace([in] VARIANT_BOOL Value);
    [propget, id(0x00000011), helpstring("Price Signal for the Circuit\0er to trace the control actions to a file.\0ters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PriceSignal([out, retval] double* Value);
    [propput, id(0x00000011), helpstring("Price Signal for the Circuit\0er to trace the control actions to a file.\0ters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PriceSignal([in] double Value);
    [propget, id(0x00000012), helpstring("Name of LoadShape object that serves as the source of price signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PriceCurve([out, retval] BSTR* Value);
    [propput, id(0x00000012), helpstring("Name of LoadShape object that serves as the source of price signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PriceCurve([in] BSTR Value);
  };

  [
    uuid(E1616BDB-589B-4E5D-A7CE-828ACD73E5D4),
    version(1.0),
    helpstring("Dispatch interface for Lines Object\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ILines: IDispatch
  {
    [propget, id(0x00000006), helpstring("Specify the name of the Line element to set it active.\0rice signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x00000006), helpstring("Specify the name of the Line element to set it active.\0rice signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x00000007), helpstring("Names of all Line Objects\0ne element to set it active.\0rice signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x00000008), helpstring("Invoking this property sets the first element active.  Returns 0 if no lines.  Otherwise, index of the line element.\0 some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x00000009), helpstring("Invoking this property advances to the next Line element active.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [id(0x0000000A), helpstring("Creates a new Line and makes it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall New([in] BSTR Name, [out, retval] long* Value);
    [propget, id(0x0000000B), helpstring("Name of bus for terminal 1.\0 it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Bus1([out, retval] BSTR* Value);
    [propput, id(0x0000000B), helpstring("Name of bus for terminal 1.\0 it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Bus1([in] BSTR Value);
    [propget, id(0x0000000C), helpstring("Name of bus for terminal 2.\0 it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Bus2([out, retval] BSTR* Value);
    [propput, id(0x0000000C), helpstring("Name of bus for terminal 2.\0 it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Bus2([in] BSTR Value);
    [propget, id(0x0000000D), helpstring("Name of LineCode object that defines the impedances.\0ement.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LineCode([out, retval] BSTR* Value);
    [propput, id(0x0000000D), helpstring("Name of LineCode object that defines the impedances.\0ement.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LineCode([in] BSTR Value);
    [propget, id(0x0000000E), helpstring("Length of line section in units compatible with the LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Length([out, retval] double* Value);
    [propput, id(0x0000000E), helpstring("Length of line section in units compatible with the LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Length([in] double Value);
    [propget, id(0x0000000F), helpstring("Number of Phases, this Line element.\0tible with the LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Phases([out, retval] long* Value);
    [propput, id(0x0000000F), helpstring("Number of Phases, this Line element.\0tible with the LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Phases([in] long Value);
    [propget, id(0x00000010), helpstring("Positive Sequence resistance, ohms per unit length.\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R1([out, retval] double* Value);
    [propput, id(0x00000010), helpstring("Positive Sequence resistance, ohms per unit length.\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R1([in] double Value);
    [propget, id(0x00000011), helpstring("Positive Sequence reactance, ohms per unit length.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall X1([out, retval] double* Value);
    [propput, id(0x00000011), helpstring("Positive Sequence reactance, ohms per unit length.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall X1([in] double Value);
    [propget, id(0x00000012), helpstring("Zero Sequence resistance, ohms per unit length.\0h.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R0([out, retval] double* Value);
    [propput, id(0x00000012), helpstring("Zero Sequence resistance, ohms per unit length.\0h.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R0([in] double Value);
    [propget, id(0x00000013), helpstring("Zero Sequence reactance ohms per unit length.\0.\0h.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall X0([out, retval] double* Value);
    [propput, id(0x00000013), helpstring("Zero Sequence reactance ohms per unit length.\0.\0h.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall X0([in] double Value);
    [propget, id(0x00000014), helpstring("Positive Sequence capacitance, nanofarads per unit length.\0e definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall C1([out, retval] double* Value);
    [propput, id(0x00000014), helpstring("Positive Sequence capacitance, nanofarads per unit length.\0e definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall C1([in] double Value);
    [propget, id(0x00000015), helpstring("Zero Sequence capacitance, nanofarads per unit length.\0th.\0e definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall C0([out, retval] double* Value);
    [propput, id(0x00000015), helpstring("Zero Sequence capacitance, nanofarads per unit length.\0th.\0e definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall C0([in] double Value);
    [propget, id(0x00000016), helpstring("Resistance matrix (full), ohms per unit length. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rmatrix([out, retval] VARIANT* Value);
    [propput, id(0x00000016), helpstring("Resistance matrix (full), ohms per unit length. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rmatrix([in] VARIANT Value);
    [propget, id(0x00000017)]
    HRESULT _stdcall Xmatrix([out, retval] VARIANT* Value);
    [propput, id(0x00000017)]
    HRESULT _stdcall Xmatrix([in] VARIANT Value);
    [propget, id(0x00000018)]
    HRESULT _stdcall Cmatrix([out, retval] VARIANT* Value);
    [propput, id(0x00000018)]
    HRESULT _stdcall Cmatrix([in] VARIANT Value);
    [propget, id(0x00000019), helpstring("Normal ampere rating of Line.\0 per unit length. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormAmps([out, retval] double* Value);
    [propput, id(0x00000019), helpstring("Normal ampere rating of Line.\0 per unit length. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormAmps([in] double Value);
    [propget, id(0x0000001A), helpstring("Emergency (maximum) ampere rating of Line.\0gth. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergAmps([out, retval] double* Value);
    [propput, id(0x0000001A), helpstring("Emergency (maximum) ampere rating of Line.\0gth. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergAmps([in] double Value);
    [propget, id(0x00000001), helpstring("Line geometry code\0 ampere rating of Line.\0gth. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Geometry([out, retval] BSTR* Value);
    [propput, id(0x00000001), helpstring("Line geometry code\0 ampere rating of Line.\0gth. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Geometry([in] BSTR Value);
    [propget, id(0x00000002), helpstring("Earth return resistance value used to compute line impedances at power frequency\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rg([out, retval] double* Value);
    [propput, id(0x00000002), helpstring("Earth return resistance value used to compute line impedances at power frequency\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rg([in] double Value);
    [propget, id(0x00000003), helpstring("Earth return reactance value used to compute line impedances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xg([out, retval] double* Value);
    [propput, id(0x00000003), helpstring("Earth return reactance value used to compute line impedances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xg([in] double Value);
    [propget, id(0x00000004), helpstring("Earth Resistivity, m-ohms\0ue used to compute line impedances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rho([out, retval] double* Value);
    [propput, id(0x00000004), helpstring("Earth Resistivity, m-ohms\0ue used to compute line impedances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rho([in] double Value);
    [propget, id(0x00000005), helpstring("Yprimitive: Does Nothing at present on Put; Dangerous\0dances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Yprim([out, retval] VARIANT* Value);
    [propput, id(0x00000005), helpstring("Yprimitive: Does Nothing at present on Put; Dangerous\0dances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Yprim([in] VARIANT Value);
    [propget, id(0x000000C9), helpstring("Number of customers on this line section.\0; Dangerous\0dances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumCust([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Total Number of customers served from this line section.\0ces at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TotalCust([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets Parent of the active Line to be the active line. Returns 0 if no parent or action fails.\0 Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Parent([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Number of Line objects in Active Circuit.\0ctive line. Returns 0 if no parent or action fails.\0 Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Line spacing code")]
    HRESULT _stdcall Spacing([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Line spacing code")]
    HRESULT _stdcall Spacing([in] BSTR Value);
    [propget, id(0x000000CE)]
    HRESULT _stdcall Units([out, retval] long* Value);
    [propput, id(0x000000CE)]
    HRESULT _stdcall Units([in] long Value);
    [propget, id(0x000000CF), helpstring("Delivers the rating for the current season (in Amps)  if the SeasonalRatings option is active")]
    HRESULT _stdcall SeasonRating([out, retval] double* Value);
  };

  [
    uuid(55055001-5EEC-4667-9CCA-63F3A60F31F3),
    version(1.0),
    helpstring("Interface for CtrlQueue Object\0ject\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ICtrlQueue: IDispatch
  {
    [id(0x00000065), helpstring("Clear control queue\0ts in Active Circuit.\0ctive line. Returns 0 if no parent or action fails.\0 Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ClearQueue(void);
    [id(0x00000067), helpstring("Delete a control action from the DSS control queue by referencing the handle of the action\0s.\0 Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delete([in] long ActionHandle);
    [propget, id(0x00000068), helpstring("Number of Actions on the current actionlist (that have been popped off the control queue by CheckControlActions)\0f the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumActions([out, retval] long* Value);
    [propput, id(0x00000066), helpstring("Set the active action by index\0t actionlist (that have been popped off the control queue by CheckControlActions)\0f the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Action([in] long Param1);
    [propget, id(0x00000069), helpstring("Code for the active action. Long integer code to tell the control device what to do\0ueue by CheckControlActions)\0f the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActionCode([out, retval] long* Value);
    [propget, id(0x0000006A), helpstring("Handle (User defined) to device that must act on the pending action.\0ice what to do\0ueue by CheckControlActions)\0f the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DeviceHandle([out, retval] long* Value);
    [id(0x0000006B), helpstring("Push a control action onto the DSS control queue by time, action code, and device handle (user defined). Returns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Push([in] long Hour, [in] double Seconds, [in] long ActionCode, [in] long DeviceHandle, [out, retval] long* Value);
    [id(0x0000006C), helpstring("Show entire control queue in CSV format\0ol queue by time, action code, and device handle (user defined). Returns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Show(void);
    [id(0x0000006D), helpstring("Clear the Action list.\0ue in CSV format\0ol queue by time, action code, and device handle (user defined). Returns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ClearActions(void);
    [propget, id(0x0000006E), helpstring("Pops next action off the action list and makes it the active action. Returns zero if none.")]
    HRESULT _stdcall PopAction([out, retval] long* Value);
    [propget, id(0x000000C9), helpstring("Number of items on the OpenDSS control Queue")]
    HRESULT _stdcall QueueSize([out, retval] long* Value);
    [id(0x000000CA), helpstring("Do All Actions currently on the Control queue. Side effect: clears the queue")]
    HRESULT _stdcall DoAllQueue(void);
    [propget, id(0x000000CB), helpstring("Variant array of strings containing the entire queue in CSV format")]
    HRESULT _stdcall Queue([out, retval] VARIANT* Value);
  };

  [
    uuid(9A3FFA05-5B82-488C-B08D-FCA2FDB23101),
    version(1.0),
    helpstring("Dispatch interface for Loads Object\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ILoads: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings containing all Load names\0he active action. Returns Number of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Set first Load element to be active; returns 0 if none.\0tive action. Returns Number of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets next Load element to be active; returns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Set active load by name.\0 be active; returns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CC), helpstring("Set active load by name.\0 be active; returns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("Sets active load by index into load list. 1..Count")]
    HRESULT _stdcall Idx([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("Sets active load by index into load list.  1..Count")]
    HRESULT _stdcall Idx([in] long Value);
    [propget, id(0x000000CE), helpstring("Set kW for active Load. Updates kvar based on present PF.")]
    HRESULT _stdcall kW([out, retval] double* Value);
    [propput, id(0x000000CE), helpstring("Set kW for active Load. Updates kvar based on present PF.")]
    HRESULT _stdcall kW([in] double Value);
    [propget, id(0x000000CF), helpstring("Set kV rating for active Load. For 2 or more phases set Line-Line kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Set kV rating for active Load. For 2 or more phases set Line-Line kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([in] double Value);
    [propget, id(0x000000D0), helpstring("Set kvar for active Load. Updates PF based in present kW.")]
    HRESULT _stdcall kvar([out, retval] double* Value);
    [propput, id(0x000000D0), helpstring("Set kvar for active Load. Updates PF based on present kW.")]
    HRESULT _stdcall kvar([in] double Value);
    [propget, id(0x000000D1), helpstring("Set Power Factor for Active Load. Specify leading PF as negative. Updates kvar based on kW value")]
    HRESULT _stdcall PF([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Set Power Factor for Active Load. Specify leading PF as negative. Updates kvar based on present value of kW.")]
    HRESULT _stdcall PF([in] double Value);
    [propget, id(0x000000D2), helpstring("Number of Load objects in active circuit.\0leading PF as negative.\0kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000D3), helpstring("Average percent of nominal load in Monte Carlo studies; only if no loadshape defined for this load.")]
    HRESULT _stdcall PctMean([out, retval] double* Value);
    [propput, id(0x000000D3)]
    HRESULT _stdcall PctMean([in] double Value);
    [propget, id(0x000000D4), helpstring("Percent standard deviation for Monte Carlo load studies; if there is no loadshape assigned to this load.")]
    HRESULT _stdcall PctStdDev([out, retval] double* Value);
    [propput, id(0x000000D4)]
    HRESULT _stdcall PctStdDev([in] double Value);
    [propget, id(0x000000D5), helpstring("Factor for allocating loads by connected xfkva")]
    HRESULT _stdcall AllocationFactor([out, retval] double* Value);
    [propput, id(0x000000D5)]
    HRESULT _stdcall AllocationFactor([in] double Value);
    [propget, id(0x000000D6), helpstring("Factor relates average to peak kw.  Used for allocation with kwh and kwhdays/")]
    HRESULT _stdcall Cfactor([out, retval] double* Value);
    [propput, id(0x000000D6)]
    HRESULT _stdcall Cfactor([in] double Value);
    [propget, id(0x000000D7), helpstring("A code number used to separate loads by class or group. No effect on the solution.")]
    HRESULT _stdcall Class([out, retval] long* Value);
    [propput, id(0x000000D7)]
    HRESULT _stdcall Class([in] long Value);
    [propget, id(0x000000D8), helpstring("Delta loads are connected line-to-line.")]
    HRESULT _stdcall IsDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D8)]
    HRESULT _stdcall IsDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000D9), helpstring("Name of a loadshape with both Mult and Qmult, for CVR factors as a function of time.")]
    HRESULT _stdcall CVRcurve([out, retval] BSTR* Value);
    [propput, id(0x000000D9)]
    HRESULT _stdcall CVRcurve([in] BSTR Value);
    [propget, id(0x000000DA), helpstring("Percent reduction in P for percent reduction in V. Must be used with dssLoadModelCVR.")]
    HRESULT _stdcall CVRwatts([out, retval] double* Value);
    [propput, id(0x000000DA)]
    HRESULT _stdcall CVRwatts([in] double Value);
    [propget, id(0x000000DB), helpstring("Percent reduction in Q for percent reduction in V. Must be used with dssLoadModelCVR.")]
    HRESULT _stdcall CVRvars([out, retval] double* Value);
    [propput, id(0x000000DB)]
    HRESULT _stdcall CVRvars([in] double Value);
    [propget, id(0x000000DC), helpstring("Name of the loadshape for a daily load profile.")]
    HRESULT _stdcall daily([out, retval] BSTR* Value);
    [propput, id(0x000000DC)]
    HRESULT _stdcall daily([in] BSTR Value);
    [propget, id(0x000000DD), helpstring("Name of the loadshape for a duty cycle simulation.")]
    HRESULT _stdcall duty([out, retval] BSTR* Value);
    [propput, id(0x000000DD)]
    HRESULT _stdcall duty([in] BSTR Value);
    [propget, id(0x000000DF), helpstring("Base load kva. Also defined kw and kvar or pf input, or load allocation by kwh or xfkva.")]
    HRESULT _stdcall kva([out, retval] double* Value);
    [propput, id(0x000000DF)]
    HRESULT _stdcall kva([in] double Value);
    [propget, id(0x000000E0), helpstring("kwh billed for this period. Can be used with Cfactor for load allocation.")]
    HRESULT _stdcall kwh([out, retval] double* Value);
    [propput, id(0x000000E0)]
    HRESULT _stdcall kwh([in] double Value);
    [propget, id(0x000000E1), helpstring("Length of kwh billing period for average demand calculation. Default 30.")]
    HRESULT _stdcall kwhdays([out, retval] double* Value);
    [propput, id(0x000000E1)]
    HRESULT _stdcall kwhdays([in] double Value);
    [propget, id(0x000000E2), helpstring("The Load Model defines variation of P and Q with voltage.")]
    HRESULT _stdcall Model([out, retval] enum LoadModels* Value);
    [propput, id(0x000000E2)]
    HRESULT _stdcall Model([in] enum LoadModels Value);
    [propget, id(0x000000E3), helpstring("Number of customers in this load, defaults to one.")]
    HRESULT _stdcall NumCust([out, retval] long* Value);
    [propput, id(0x000000E3)]
    HRESULT _stdcall NumCust([in] long Value);
    [propget, id(0x000000E4), helpstring("Neutral resistance for wye-connected loads.")]
    HRESULT _stdcall Rneut([out, retval] double* Value);
    [propput, id(0x000000E4)]
    HRESULT _stdcall Rneut([in] double Value);
    [propget, id(0x000000E5), helpstring("Name of harmonic current spectrrum shape.")]
    HRESULT _stdcall Spectrum([out, retval] BSTR* Value);
    [propput, id(0x000000E5)]
    HRESULT _stdcall Spectrum([in] BSTR Value);
    [propget, id(0x000000E6), helpstring("Maximum per-unit voltage to use the load model. Above this, constant Z applies.")]
    HRESULT _stdcall Vmaxpu([out, retval] double* Value);
    [propput, id(0x000000E6)]
    HRESULT _stdcall Vmaxpu([in] double Value);
    [propget, id(0x000000E7), helpstring("Minimum voltage for unserved energy (UE) evaluation.")]
    HRESULT _stdcall Vminemerg([out, retval] double* Value);
    [propput, id(0x000000E7)]
    HRESULT _stdcall Vminemerg([in] double Value);
    [propget, id(0x000000E8), helpstring("Minimum voltage for energy exceeding normal (EEN) evaluations.")]
    HRESULT _stdcall Vminnorm([out, retval] double* Value);
    [propput, id(0x000000E8)]
    HRESULT _stdcall Vminnorm([in] double Value);
    [propget, id(0x000000E9), helpstring("Minimum voltage to apply the load model. Below this, constant Z is used.")]
    HRESULT _stdcall Vminpu([out, retval] double* Value);
    [propput, id(0x000000E9)]
    HRESULT _stdcall Vminpu([in] double Value);
    [propget, id(0x000000EA), helpstring("Rated service transformer kVA for load allocation, using AllocationFactor. Affects kW, kvar, and pf.")]
    HRESULT _stdcall xfkVA([out, retval] double* Value);
    [propput, id(0x000000EA)]
    HRESULT _stdcall xfkVA([in] double Value);
    [propget, id(0x000000EB), helpstring("Neutral reactance for wye-connected loads.")]
    HRESULT _stdcall Xneut([out, retval] double* Value);
    [propput, id(0x000000EB)]
    HRESULT _stdcall Xneut([in] double Value);
    [propget, id(0x000000EC), helpstring("Name of yearly duration loadshape")]
    HRESULT _stdcall Yearly([out, retval] BSTR* Value);
    [propput, id(0x000000EC)]
    HRESULT _stdcall Yearly([in] BSTR Value);
    [propget, id(0x000000ED), helpstring("Response to load multipliers: Fixed (growth only), Exempt (no LD curve), Variable (all).")]
    HRESULT _stdcall Status([out, retval] enum LoadStatus* Value);
    [propput, id(0x000000ED)]
    HRESULT _stdcall Status([in] enum LoadStatus Value);
    [propget, id(0x000000DE), helpstring("Name of the growthshape curve for yearly load growth factors.")]
    HRESULT _stdcall Growth([out, retval] BSTR* Value);
    [propput, id(0x000000DE)]
    HRESULT _stdcall Growth([in] BSTR Value);
    [propget, id(0x000000EE), helpstring("Array of 7  doubles with values for ZIPV property of the LOAD object")]
    HRESULT _stdcall ZIPV([out, retval] VARIANT* Value);
    [propput, id(0x000000EE)]
    HRESULT _stdcall ZIPV([in] VARIANT Value);
    [propget, id(0x000000EF)]
    HRESULT _stdcall pctSeriesRL([out, retval] double* Value);
    [propput, id(0x000000EF), helpstring("Percent of Load that is modeled as series R-L for harmonics studies")]
    HRESULT _stdcall pctSeriesRL([in] double Value);
    [propget, id(0x000000F0), helpstring("Relative Weighting factor for the active LOAD")]
    HRESULT _stdcall RelWeight([out, retval] double* Value);
    [propput, id(0x000000F0), helpstring("Relative Weighting factor for the active LOAD")]
    void _stdcall RelWeight([in] double Value);
  };

  [
    uuid(C22D4922-6DC2-4283-93AB-4F2138C4B922),
    version(1.0),
    helpstring("Dispatch interface for DSSElement Object\0\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IDSSElement: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Full Name of Active DSS Object (general element or circuit element).\0 Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propget, id(0x000000CA), helpstring("Collection of properties for Active DSS object (general element or circuit element).\0across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Properties([in] VARIANT Indx, [out, retval] IDSSProperty** Value);
    [propget, id(0x000000CB), helpstring("Number of Properties for the active DSS object.\0general element or circuit element).\0across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumProperties([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Variant array of strings containing the names of all properties for the active DSS object.\0 terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllPropertyNames([out, retval] VARIANT* Value);
  };

  [
    uuid(8E73B64C-0D99-4D19-AB90-170DBBD06FA0),
    version(1.0),
    helpstring("Dispatch interface for ActiveClass Object\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IActiveClass: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings consisting of all element names in the active class.\0 DSS object.\0 terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Sets first element in the active class to be the active DSS object. If object is a CktElement, ActiveCktELment also points to this element. Returns 0 if none.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets next element in active class to be the active DSS object. If object is a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Name of the Active Element of the Active Class")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CC)]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("Number of elements in this class. Same as Count property.\0ect. If object is a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumElements([out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Returns name of active class.\0ss. Same as Count property.\0ect. If object is a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveClassName([out, retval] BSTR* Value);
    [propget, id(0x000000CF), helpstring("Number of elements in Active Class. Same as NumElements Property.\0object is a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000D0), helpstring("Use this property (Read only) for getting the name of the parent class' name of the active class")]
    HRESULT _stdcall ActiveClassParent([out, retval] BSTR* Value);
  };

  [
    uuid(3C171A69-40AB-46AA-B037-9C4EBB9FBFCD),
    version(1.0),
    helpstring("Dispatch interface for Capacitors\0 Object\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ICapacitors: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Bank kV rating. Use LL for 2 or 3 phases, or actual can rating for 1 phase.\0a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([out, retval] double* Value);
    [propput, id(0x000000C9), helpstring("Bank kV rating. Use LL for 2 or 3 phases, or actual can rating for 1 phase.\0a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([in] double Value);
    [propget, id(0x000000CA), helpstring("Total bank KVAR, distributed equally among phases and steps.\0g for 1 phase.\0a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kvar([out, retval] double* Value);
    [propput, id(0x000000CA), helpstring("Total bank KVAR, distributed equally among phases and steps.\0g for 1 phase.\0a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kvar([in] double Value);
    [propget, id(0x000000CB), helpstring("Number of steps (default 1) for distributing and switching the total bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumSteps([out, retval] long* Value);
    [propput, id(0x000000CB), helpstring("Number of steps (default 1) for distributing and switching the total bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumSteps([in] long Value);
    [propget, id(0x000000CC), helpstring("Delta connection or wye?\x01) for distributing and switching the total bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CC), helpstring("Delta connection or wye?\x01) for distributing and switching the total bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000CD), helpstring("Variant array of strings with all Capacitor names in the circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("Sets the first Capacitor active. Returns 0 if no more.\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CF), helpstring("Sets the next Capacitor active. Returns 0 if no more.\0\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000D0), helpstring("Sets the acitve Capacitor by Name.\0urns 0 if no more.\0\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000D0), helpstring("Sets the acitve Capacitor by Name.\0urns 0 if no more.\0\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("Number of Capacitor objects in active circuit.\0 more.\0\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [id(0x000000D2), helpstring("Adds one step of the capacitor if available. If successful returns TRUE.")]
    HRESULT _stdcall AddStep([out, retval] VARIANT_BOOL* value);
    [id(0x000000D3), helpstring("Subtract one capacitor step.  Returns False if no more steps.")]
    HRESULT _stdcall SubtractStep([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000D4), helpstring("Number of Steps available in cap bank to be switched ON.")]
    HRESULT _stdcall AvailableSteps([out, retval] long* Value);
    [propget, id(0x000000D5), helpstring("A variant array of  integer [0..numsteps-1] indicating state of each step. If value is -1 an error has occurred.")]
    HRESULT _stdcall States([out, retval] VARIANT* Value);
    [propput, id(0x000000D5), helpstring("Variant array of integer [0 ..numSteps-1] indicating the state of each step")]
    HRESULT _stdcall States([in] VARIANT Value);
    [id(0x000000D6), helpstring("Open all steps, all phases of the Capacitor ")]
    HRESULT _stdcall Open(void);
    [id(0x000000D7), helpstring("Close all phases of all steps of the Capacitor")]
    HRESULT _stdcall Close(void);
  };

  [
    uuid(94E9CACF-A548-4DC2-B460-E2642B501387),
    version(1.0),
    helpstring("Dispatch interface for Transformers\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ITransformers: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of windings on this transformer. Allocates memory; set or change this property first.\0iveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumWindings([out, retval] long* Value);
    [propput, id(0x000000C9), helpstring("Number of windings on this transformer. Allocates memory; set or change this property first.\0iveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumWindings([in] long Value);
    [propget, id(0x000000CA), helpstring("Name of an XfrmCode that supplies electircal parameters for this Transformer.\0roperty first.\0iveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall XfmrCode([out, retval] BSTR* Value);
    [propput, id(0x000000CA), helpstring("Name of an XfrmCode that supplies electircal parameters for this Transformer.\0roperty first.\0iveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall XfmrCode([in] BSTR Value);
    [propget, id(0x000000CB), helpstring("Active Winding Number from 1..NumWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Wdg([out, retval] long* Value);
    [propput, id(0x000000CB), helpstring("Active Winding Number from 1..NumWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Wdg([in] long Value);
    [propget, id(0x000000CC), helpstring("Active Winding resistance in %\0umWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R([out, retval] double* Value);
    [propput, id(0x000000CC), helpstring("Active Winding resistance in %\0umWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R([in] double Value);
    [propget, id(0x000000CD), helpstring("Active Winding tap in per-unit.\0mWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Tap([out, retval] double* Value);
    [propput, id(0x000000CD), helpstring("Active Winding tap in per-unit.\0mWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Tap([in] double Value);
    [propget, id(0x000000CE), helpstring("Active Winding minimum tap in per-unit.\0s. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MinTap([out, retval] double* Value);
    [propput, id(0x000000CE), helpstring("Active Winding minimum tap in per-unit.\0s. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MinTap([in] double Value);
    [propget, id(0x000000CF), helpstring("Active Winding maximum tap in per-unit.\0s. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxTap([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Active Winding maximum tap in per-unit.\0s. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxTap([in] double Value);
    [propget, id(0x000000D0), helpstring("Active Winding number of tap steps betwein MinTap and MaxTap.\0reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumTaps([out, retval] long* Value);
    [propput, id(0x000000D0), helpstring("Active Winding number of tap steps betwein MinTap and MaxTap.\0reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumTaps([in] long Value);
    [propget, id(0x000000D1), helpstring("Active Winding kV rating.  Phase-phase for 2 or 3 phases, actual winding kV for 1 phase transformer.\0g properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Active Winding kV rating.  Phase-phase for 2 or 3 phases, actual winding kV for 1 phase transformer.\0g properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([in] double Value);
    [propget, id(0x000000D2), helpstring("Active Winding kVA rating. On winding 1, this also determines normal and emergency current ratings for all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kVA([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("Active Winding kVA rating. On winding 1, this also determines normal and emergency current ratings for all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kVA([in] double Value);
    [propget, id(0x000000D3), helpstring("Active Winding neutral reactance [ohms] for wye connections.\0 normal and emergency current ratings for all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xneut([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Active Winding neutral reactance [ohms] for wye connections.\0 normal and emergency current ratings for all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xneut([in] double Value);
    [propget, id(0x000000D4), helpstring("Active Winding neutral resistance [ohms] for wye connections. Set less than zero for ungrounded wye.\0r all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rneut([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Active Winding neutral resistance [ohms] for wye connections. Set less than zero for ungrounded wye.\0r all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rneut([in] double Value);
    [propget, id(0x000000D5), helpstring("Active Winding delta or wye connection?\0 for wye connections. Set less than zero for ungrounded wye.\0r all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D5), helpstring("Active Winding delta or wye connection?\0 for wye connections. Set less than zero for ungrounded wye.\0r all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000D6), helpstring("Percent reactance between windings 1 and 2, on winding 1 kVA base. Use for 2-winding or 3-winding transformers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xhl([out, retval] double* Value);
    [propput, id(0x000000D6), helpstring("Percent reactance between windings 1 and 2, on winding 1 kVA base. Use for 2-winding or 3-winding transformers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xhl([in] double Value);
    [propget, id(0x000000D7), helpstring("Percent reactance between windigns 1 and 3, on winding 1 kVA base.  Use for 3-winding transformers only.\0rmers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xht([out, retval] double* Value);
    [propput, id(0x000000D7), helpstring("Percent reactance between windigns 1 and 3, on winding 1 kVA base.  Use for 3-winding transformers only.\0rmers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xht([in] double Value);
    [propget, id(0x000000D8), helpstring("Percent reactance between windings 2 and 3, on winding 1 kVA base. Use for 3-winding transformers only.")]
    HRESULT _stdcall Xlt([out, retval] double* Value);
    [propput, id(0x000000D8), helpstring("Percent reactance between windings 2 and 3, on winding 1 kVA base. Use for 3-winding transformers only.")]
    HRESULT _stdcall Xlt([in] double Value);
    [propget, id(0x000000D9), helpstring("Sets a Transformer active by Name.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000D9), helpstring("Sets a Transformer active by Name.")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000DA), helpstring("Sets the first Transformer active. Returns 0 if no more.\0_ kVA base. Use for 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000DB), helpstring("Sets the next Transformer active. Returns 0 if no more.\0\0_ kVA base. Use for 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000DC), helpstring("Variant array of strings with all Transformer names in the active circuit.\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000DD)]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000DE), helpstring("Complex array of voltages for active winding")]
    HRESULT _stdcall WdgVoltages([out, retval] VARIANT* Value);
    [propget, id(0x000000DF), helpstring("All Winding currents (ph1, wdg1, wdg2,... ph2, wdg1, wdg2 ...)")]
    HRESULT _stdcall WdgCurrents([out, retval] VARIANT* Value);
    [propget, id(0x000000E0), helpstring("All winding currents in CSV string form like the WdgCurrents property")]
    HRESULT _stdcall strWdgCurrents([out, retval] BSTR* Value);
    [propget, id(0x000000E1), helpstring("Transformer Core Type: 0=shell;1 = 1-phase; 3= 3-leg; 5= 5-leg")]
    HRESULT _stdcall CoreType([out, retval] long* Value);
    [propput, id(0x000000E1)]
    HRESULT _stdcall CoreType([in] long Value);
    [propget, id(0x000000E2)]
    HRESULT _stdcall RdcOhms([out, retval] double* Value);
    [propput, id(0x000000E2), helpstring("dc Resistance of active winding in ohms for GIC analysis")]
    HRESULT _stdcall RdcOhms([in] double Value);
  };

  [
    uuid(112AB9E6-C112-46BE-A8A3-F72C5FA3A657),
    version(1.0),
    helpstring("Dispatch interface for SwtControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ISwtControls: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings with all SwtControl names in the active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Sets a SwtControl active by Name.\0SwtControl names in the active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CA), helpstring("Sets a SwtControl active by Name.\0SwtControl names in the active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CB), helpstring("Sets the first SwtControl active. Returns 0 if no more.\0e active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next SwtControl active. Returns 0 if no more.\0\0e active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Open or Close the switch. No effect if switch is locked.  However, Reset removes any lock and then closes the switch (shelf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Action([out, retval] enum ActionCodes* Value);
    [propput, id(0x000000CD), helpstring("Open or Close the switch. No effect if switch is locked.  However, Reset removes any lock and then closes the switch (shelf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Action([in] enum ActionCodes Value);
    [propget, id(0x000000CE), helpstring("The lock prevents both manual and automatic switch operation.\0ver, Reset removes any lock and then closes the switch (shelf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsLocked([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CE), helpstring("The lock prevents both manual and automatic switch operation.\0ver, Reset removes any lock and then closes the switch (shelf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsLocked([in] VARIANT_BOOL Value);
    [propget, id(0x000000CF), helpstring("Time delay [s] betwen arming and opening or closing the switch.  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Time delay [s] betwen arming and opening or closing the switch.  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([in] double Value);
    [propget, id(0x000000D0), helpstring("Full name of the switched element.\0ening or closing the switch.  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwitchedObj([out, retval] BSTR* Value);
    [propput, id(0x000000D0), helpstring("Full name of the switched element.\0ening or closing the switch.  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwitchedObj([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("Terminal number where the switch is located on the SwitchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwitchedTerm([out, retval] long* Value);
    [propput, id(0x000000D1), helpstring("Terminal number where the switch is located on the SwitchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwitchedTerm([in] long Value);
    [propget, id(0x000000D2)]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000D3), helpstring("Get Normal state of switch")]
    HRESULT _stdcall NormalState([out, retval] enum ActionCodes* Value);
    [propput, id(0x000000D3), helpstring("set Normal state of switch  (see actioncodes) dssActionOpen or dssActionClose")]
    HRESULT _stdcall NormalState([in] enum ActionCodes Value);
    [propget, id(0x000000D4), helpstring("Force switch to specified state")]
    HRESULT _stdcall State([out, retval] enum ActionCodes* Value);
    [propput, id(0x000000D4), helpstring("Get Present state of switch")]
    HRESULT _stdcall State([in] enum ActionCodes Value);
    [id(0x000000D5), helpstring("Force a reset of this switch to NormalState, unlocked. Unlocks switch and calls Reset function.")]
    HRESULT _stdcall Reset(void);
  };

  [
    uuid(4C132096-4161-4D9B-A701-E6CCCFF1D5AE),
    version(1.0),
    helpstring("Dispatch interface for CapControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ICapControls: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings with all CapControl names.\0witchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Sets a CapControl active by name.\0CapControl names.\0witchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CA), helpstring("Sets a CapControl active by name.\0CapControl names.\0witchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CB), helpstring("Sets the first CapControl as active. Return 0 if none.\0chedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Gets the next CapControl in the circut. Returns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Type of automatic controller.\0e circut. Returns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([out, retval] enum CapControlModes* Value);
    [propput, id(0x000000CD), helpstring("Type of automatic controller.\0e circut. Returns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([in] enum CapControlModes Value);
    [propget, id(0x000000CE), helpstring("Name of the Capacitor that is controlled.\0turns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capacitor([out, retval] BSTR* Value);
    [propput, id(0x000000CE), helpstring("Name of the Capacitor that is controlled.\0turns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capacitor([in] BSTR Value);
    [propget, id(0x000000CF), helpstring("Full name of the element that PT and CT are connected to.\0\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredObj([out, retval] BSTR* Value);
    [propput, id(0x000000CF), helpstring("Full name of the element that PT and CT are connected to.\0\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredObj([in] BSTR Value);
    [propget, id(0x000000D0), helpstring("Terminal number on the element that PT and CT are connected to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredTerm([out, retval] long* Value);
    [propput, id(0x000000D0), helpstring("Terminal number on the element that PT and CT are connected to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredTerm([in] long Value);
    [propget, id(0x000000D1), helpstring("Transducer ratio from pirmary current to control current.\0d to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CTratio([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Transducer ratio from pirmary current to control current.\0d to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CTratio([in] double Value);
    [propget, id(0x000000D2), helpstring("Transducer ratio from primary feeder to control voltage.\0\0d to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PTratio([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("Transducer ratio from primary feeder to control voltage.\0\0d to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PTratio([in] double Value);
    [propget, id(0x000000D3), helpstring("Threshold to arm or switch on a step.  See Mode for units.\0 to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ONSetting([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Threshold to arm or switch on a step.  See Mode for units.\0 to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ONSetting([in] double Value);
    [propget, id(0x000000D4), helpstring("Threshold to switch off a step. See Mode for units.\0units.\0 to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall OFFSetting([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Threshold to switch off a step. See Mode for units.\0units.\0 to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall OFFSetting([in] double Value);
    [propget, id(0x000000D5), helpstring("With VoltOverride, swtich off whenever PT voltage exceeds this level.\0ol may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Vmax([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("With VoltOverride, swtich off whenever PT voltage exceeds this level.\0ol may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Vmax([in] double Value);
    [propget, id(0x000000D6), helpstring("With VoltOverride, switch ON whenever PT voltage drops below this level.\0may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Vmin([out, retval] double* Value);
    [propput, id(0x000000D6), helpstring("With VoltOverride, switch ON whenever PT voltage drops below this level.\0may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Vmin([in] double Value);
    [propget, id(0x000000D7), helpstring("Enables Vmin and Vmax to override the control Mode\0ops below this level.\0may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UseVoltOverride([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D7), helpstring("Enables Vmin and Vmax to override the control Mode\0ops below this level.\0may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UseVoltOverride([in] VARIANT_BOOL Value);
    [propget, id(0x000000D8), helpstring("Time delay [s] to switch on after arming.  Control may reset before actually switching.\0e actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([out, retval] double* Value);
    [propput, id(0x000000D8), helpstring("Time delay [s] to switch on after arming.  Control may reset before actually switching.\0e actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([in] double Value);
    [propget, id(0x000000D9), helpstring("Time delay [s] before swithcing off a step. Control may reset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DelayOff([out, retval] double* Value);
    [propput, id(0x000000D9), helpstring("Time delay [s] before swithcing off a step. Control may reset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DelayOff([in] double Value);
    [propget, id(0x000000DA)]
    HRESULT _stdcall DeadTime([out, retval] double* Value);
    [propput, id(0x000000DA)]
    HRESULT _stdcall DeadTime([in] double Value);
    [propget, id(0x000000DB), helpstring("Number of CapControls in Active Circuit\0ep. Control may reset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [id(0x000000DC), helpstring("Force a Reset of this CapControl")]
    HRESULT _stdcall Reset(void);
  };

  [
    uuid(3F983AD2-B658-4CE8-B4C1-DE0A9EDD47FD),
    version(1.0),
    helpstring("Dispatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IRegControls: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings containing all RegControl names\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Get/set Active RegControl  name")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CA), helpstring("Sets a RegControl active by name\0ng all RegControl names\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CB), helpstring("Sets the first RegControl active. Returns 0 if none.\0mes\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next RegControl active. Returns 0 if none.\0\0mes\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Name of a remote regulated bus, in lieu of LDC settings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredBus([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Name of a remote regulated bus, in lieu of LDC settings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredBus([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Name of the transformer this regulator controls\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Transformer([out, retval] BSTR* Value);
    [propput, id(0x000000CE), helpstring("Name of the transformer this regulator controls\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Transformer([in] BSTR Value);
    [propget, id(0x000000CF), helpstring("Tapped winding number\0r this regulator controls\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TapWinding([out, retval] long* Value);
    [propput, id(0x000000CF), helpstring("Tapped winding number\0r this regulator controls\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TapWinding([in] long Value);
    [propget, id(0x000000D0), helpstring("Winding number for PT and CT connections\0ntrols\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Winding([out, retval] long* Value);
    [propput, id(0x000000D0), helpstring("Winding number for PT and CT connections\0ntrols\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Winding([in] long Value);
    [propget, id(0x000000D1), helpstring("CT primary ampere rating (secondary is 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CTPrimary([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("CT primary ampere rating (secondary is 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CTPrimary([in] double Value);
    [propget, id(0x000000D2), helpstring("PT ratio for voltage control settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PTratio([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("PT ratio for voltage control settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PTratio([in] double Value);
    [propget, id(0x000000D3), helpstring("LDC R setting in Volts\0ntrol settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardR([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("LDC R setting in Volts\0ntrol settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardR([in] double Value);
    [propget, id(0x000000D4), helpstring("LDC X setting in Volts\0ntrol settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardX([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("LDC X setting in Volts\0ntrol settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardX([in] double Value);
    [propget, id(0x000000D5), helpstring("Reverse LDC R setting in Volts.\0tings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseR([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("Reverse LDC R setting in Volts.\0tings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseR([in] double Value);
    [propget, id(0x000000D6), helpstring("Reverse LDC X setting in volts.\0tings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseX([out, retval] double* Value);
    [propput, id(0x000000D6), helpstring("Reverse LDC X setting in volts.\0tings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseX([in] double Value);
    [propget, id(0x000000D7), helpstring("Regulator can use different settings in the reverse direction.  Usually not applicable to substation transformers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsReversible([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D7), helpstring("Regulator can use different settings in the reverse direction.  Usually not applicable to substation transformers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsReversible([in] VARIANT_BOOL Value);
    [propget, id(0x000000D8), helpstring("Time delay is inversely adjusted, proportional to the amount of voltage outside the regulating band.")]
    HRESULT _stdcall IsInverseTime([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D8), helpstring("Time delay is inversely adjsuted, proportinal to the amount of voltage outside the regulating band.\0 transformers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsInverseTime([in] VARIANT_BOOL Value);
    [propget, id(0x000000D9), helpstring("Time delay [s] after arming before the first tap change. Control may reset before actually changing taps.\0formers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([out, retval] double* Value);
    [propput, id(0x000000D9), helpstring("Time delay [s] after arming before the first tap change. Control may reset before actually changing taps.\0formers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([in] double Value);
    [propget, id(0x000000DA), helpstring("Time delay [s] for subsequent tap changes in a set. Control may reset before actually changing taps.\0aps.\0formers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TapDelay([out, retval] double* Value);
    [propput, id(0x000000DA), helpstring("Time delay [s] for subsequent tap changes in a set. Control may reset before actually changing taps.\0aps.\0formers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TapDelay([in] double Value);
    [propget, id(0x000000DB), helpstring("Maximum tap change per iteration in STATIC solution mode. 1 is more realistic, 16 is the default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxTapChange([out, retval] long* Value);
    [propput, id(0x000000DB), helpstring("Maximum tap change per iteration in STATIC solution mode. 1 is more realistic, 16 is the default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxTapChange([in] long Value);
    [propget, id(0x000000DC), helpstring("First house voltage limit on PT secondary base.  Setting to 0 disables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall VoltageLimit([out, retval] double* Value);
    [propput, id(0x000000DC), helpstring("First house voltage limit on PT secondary base.  Setting to 0 disables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall VoltageLimit([in] double Value);
    [propget, id(0x000000DD), helpstring("Regulation bandwidth in forward direciton, centered on Vreg\0 disables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardBand([out, retval] double* Value);
    [propput, id(0x000000DD), helpstring("Regulation bandwidth in forward direciton, centered on Vreg\0 disables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardBand([in] double Value);
    [propget, id(0x000000DE), helpstring("Target voltage in the forward direction, on PT secondary base.\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardVreg([out, retval] double* Value);
    [propput, id(0x000000DE), helpstring("Target voltage in the forward direction, on PT secondary base.\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardVreg([in] double Value);
    [propget, id(0x000000DF), helpstring("Bandwidth in reverse direction, centered on reverse Vreg.\0ase.\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseBand([out, retval] double* Value);
    [propput, id(0x000000DF), helpstring("Bandwidth in reverse direction, centered on reverse Vreg.\0ase.\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseBand([in] double Value);
    [propget, id(0x000000E0), helpstring("Target voltage in the revese direction, on PT secondary base.\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseVreg([out, retval] double* Value);
    [propput, id(0x000000E0), helpstring("Target voltage in the revese direction, on PT secondary base.\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseVreg([in] double Value);
    [propget, id(0x000000E1), helpstring("Number of RegControl objects in Active Circuit\0econdary base.\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000E2)]
    HRESULT _stdcall TapNumber([out, retval] long* Value);
    [propput, id(0x000000E2), helpstring("Integer number of the tap that the controlled transformer winding is currentliy on.")]
    HRESULT _stdcall TapNumber([in] long Value);
    [id(0x000000E3), helpstring("Force Reset of this RegControl element")]
    HRESULT _stdcall Reset(void);
  };

  [
    uuid(03FADB98-4F30-416E-ACD2-9BD987A0CBC3),
    version(1.0),
    helpstring("Dispatch interface for Topology Object\0\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ITopology: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of loops\0raphProperties; Do GetGraphProperties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall NumLoops([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Number of isolated branches (PD elements and capacitors).")]
    HRESULT _stdcall NumIsolatedBranches([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Variant array of all looped element names, by pairs.")]
    HRESULT _stdcall AllLoopedPairs([out, retval] VARIANT* Value);
    [propget, id(0x000000CC), helpstring("Variant array of all isolated branch names.")]
    HRESULT _stdcall AllIsolatedBranches([out, retval] VARIANT* Value);
    [propget, id(0x000000CD), helpstring("Number of isolated loads")]
    HRESULT _stdcall NumIsolatedLoads([out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Variant array of all isolated load names.")]
    HRESULT _stdcall AllIsolatedLoads([out, retval] VARIANT* Value);
    [propget, id(0x000000CF), helpstring("Name of the active branch.")]
    HRESULT _stdcall BranchName([out, retval] BSTR* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall BranchName([in] BSTR Value);
    [propget, id(0x000000D0), helpstring("Sets the first branch active, returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000D1), helpstring("Sets the next branch active, returns 0 if no more.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000D2), helpstring("Returns index of the active branch")]
    HRESULT _stdcall ActiveBranch([out, retval] long* Value);
    [propget, id(0x000000D3), helpstring("Move forward in the tree, return index of new active branch or 0 if no more")]
    HRESULT _stdcall ForwardBranch([out, retval] long* Value);
    [propget, id(0x000000D4), helpstring("MOve back toward the source, return index of new active branch, or 0 if no more.")]
    HRESULT _stdcall BackwardBranch([out, retval] long* Value);
    [propget, id(0x000000D5), helpstring("Move to looped branch, return index or 0 if none.")]
    HRESULT _stdcall LoopedBranch([out, retval] long* Value);
    [propget, id(0x000000D6), helpstring("Move to directly parallel branch, return index or 0 if none.")]
    HRESULT _stdcall ParallelBranch([out, retval] long* Value);
    [propget, id(0x000000D7), helpstring("First load at the active branch, return index or 0 if none.")]
    HRESULT _stdcall FirstLoad([out, retval] long* Value);
    [propget, id(0x000000D9), helpstring("Next load at the active branch, return index or 0 if no more.")]
    HRESULT _stdcall NextLoad([out, retval] long* Value);
    [propget, id(0x000000D8), helpstring("Topological depth of the active branch")]
    HRESULT _stdcall ActiveLevel([out, retval] long* Value);
    [propget, id(0x000000DA)]
    HRESULT _stdcall BusName([out, retval] BSTR* Value);
    [propput, id(0x000000DA), helpstring("Set the active branch to one containing this bus, return index or 0 if not found")]
    HRESULT _stdcall BusName([in] BSTR Value);
  };

  [
    uuid(DD7B80E9-5EFB-4E79-96CA-9C88F5A8A11C),
    version(1.0),
    helpstring("Dispatch interface for DSS_Executive Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IDSS_Executive: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of DSS Executive Commands\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall NumCommands([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Number of DSS Executive Options\0\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall NumOptions([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Get i-th command\0cutive Options\0\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall Command([in] long i, [out, retval] BSTR* Value);
    [propget, id(0x000000CC), helpstring("Get i-th option\0\0cutive Options\0\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall Option([in] long i, [out, retval] BSTR* Value);
    [propget, id(0x000000CD), helpstring("Get help string for i-th command\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall CommandHelp([in] long i, [out, retval] BSTR* Value);
    [propget, id(0x000000CE), helpstring("Get help string for i-th option\0\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall OptionHelp([in] long i, [out, retval] BSTR* Value);
    [propget, id(0x000000CF), helpstring("Get present value of i-th option\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall OptionValue([in] long i, [out, retval] BSTR* Value);
  };

  [
    uuid(3F5A5530-4E67-44BF-AE6D-561584C6BF47),
    helpstring("Dispatch interface for DSSEvents Object"),
    dual,
    oleautomation
  ]
  interface IDSSEvents: IDispatch
  {
  };

  [
    uuid(E7444ECD-B491-4D8E-A1E3-E5804BD571E2),
    helpstring("Dispatch interface for Sensors Object"),
    dual,
    oleautomation
  ]
  interface ISensors: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Name of the active sensor.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000C9), helpstring("Set the active Sensor by name.")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CA), helpstring("Number of Sensors in Active Circuit.")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets the first sensor active. Returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next Sensor active. Returns 0 if no more.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Variant array of Sensor names.")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("True if measured voltages are line-line. Currents are always line currents.")]
    HRESULT _stdcall IsDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CE)]
    HRESULT _stdcall IsDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000CF), helpstring("True if voltage measurements are 1-3, 3-2, 2-1.")]
    HRESULT _stdcall ReverseDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall ReverseDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000D0), helpstring("Assumed percent error in the Sensor measurement. Default is 1.")]
    HRESULT _stdcall PctError([out, retval] double* Value);
    [propput, id(0x000000D0)]
    HRESULT _stdcall PctError([in] double Value);
    [propget, id(0x000000D1), helpstring("Weighting factor for this Sensor measurement with respect to other Sensors. Default is 1.")]
    HRESULT _stdcall Weight([out, retval] double* Value);
    [propput, id(0x000000D1)]
    HRESULT _stdcall Weight([in] double Value);
    [propget, id(0x000000D2), helpstring("Full Name of the measured element")]
    HRESULT _stdcall MeteredElement([out, retval] BSTR* Value);
    [propput, id(0x000000D2)]
    HRESULT _stdcall MeteredElement([in] BSTR Value);
    [propget, id(0x000000D3), helpstring("Number of the measured terminal in the measured element.")]
    HRESULT _stdcall MeteredTerminal([out, retval] long* Value);
    [propput, id(0x000000D3)]
    HRESULT _stdcall MeteredTerminal([in] long Value);
    [id(0x000000D4), helpstring("Clear the active Sensor.")]
    HRESULT _stdcall Reset(void);
    [id(0x000000D5), helpstring("Clear all Sensors in the Active Circuit.")]
    HRESULT _stdcall ResetAll(void);
    [propget, id(0x000000D6), helpstring("Voltage base for the sensor measurements. LL for 2 and 3-phase sensors, LN for 1-phase sensors.")]
    HRESULT _stdcall kVbase([out, retval] double* Value);
    [propput, id(0x000000D6)]
    HRESULT _stdcall kVbase([in] double Value);
    [propget, id(0x000000D7), helpstring("Array of doubles for the line current measurements; don't use with kWS and kVARS.")]
    HRESULT _stdcall Currents([out, retval] VARIANT* Value);
    [propput, id(0x000000D7)]
    HRESULT _stdcall Currents([in] VARIANT Value);
    [propget, id(0x000000D8), helpstring("Array of doubles for the LL or LN (depending on Delta connection) voltage measurements.")]
    HRESULT _stdcall kVS([out, retval] VARIANT* Value);
    [propput, id(0x000000D8)]
    HRESULT _stdcall kVS([in] VARIANT Value);
    [propget, id(0x000000D9), helpstring("Array of doubles for Q measurements. Overwrites Currents with a new estimate using kWS.")]
    HRESULT _stdcall kVARS([out, retval] VARIANT* Value);
    [propput, id(0x000000D9)]
    HRESULT _stdcall kVARS([in] VARIANT Value);
    [propget, id(0x000000DA), helpstring("Array of doubles for P measurements. Overwrites Currents with a new estimate using kVARS.")]
    HRESULT _stdcall kWS([out, retval] VARIANT* Value);
    [propput, id(0x000000DA)]
    HRESULT _stdcall kWS([in] VARIANT Value);
  };

  [
    uuid(97AA7680-E994-4A0C-BAC3-9B67BA49825C),
    helpstring("Dispatch interface for XYCurves Object"),
    dual,
    oleautomation
  ]
  interface IXYCurves: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of XYCurve Objects")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Sets first XYcurve object active; returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Advances to next XYCurve object; returns 0 if no more objects of this class")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Name of active XYCurve Object")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CC), helpstring("Get Name of active XYCurve Object")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("Get/Set Number of points in X-Y curve")]
    HRESULT _stdcall Npts([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("Get/Set Number of Points in X-Y curve")]
    HRESULT _stdcall Npts([in] long Value);
    [propget, id(0x000000CE), helpstring("Get/Set X values as a Variant array of doubles. Set Npts to max number expected if setting")]
    HRESULT _stdcall Xarray([out, retval] VARIANT* Value);
    [propput, id(0x000000CE), helpstring("Get/Set X values as a Variant array of doubles. Set Npts to max number expected if setting")]
    HRESULT _stdcall Xarray([in] VARIANT Value);
    [propget, id(0x000000CF), helpstring("Get/Set Y values in curve; Set Npts to max number expected if setting")]
    HRESULT _stdcall Yarray([out, retval] VARIANT* Value);
    [propput, id(0x000000CF), helpstring("Get/Set Y values in curve; Set Npts to max number expected if setting")]
    void _stdcall Yarray([in] VARIANT Value);
    [propget, id(0x000000D0), helpstring("Set X value or get interpolated value after setting Y")]
    HRESULT _stdcall x([out, retval] double* Value);
    [propput, id(0x000000D0)]
    HRESULT _stdcall x([in] double Value);
    [propget, id(0x000000D1), helpstring("Y value for present X or set this value then get corresponding X")]
    HRESULT _stdcall y([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Set Y value or get interpolated Y value after setting X")]
    HRESULT _stdcall y([in] double Value);
    [propget, id(0x000000D2), helpstring("Amount to shift X value from original curve")]
    HRESULT _stdcall Xshift([out, retval] double* Value);
    [propput, id(0x000000D2)]
    HRESULT _stdcall Xshift([in] double Value);
    [propget, id(0x000000D3), helpstring("amount to shift Y valiue from original curve")]
    HRESULT _stdcall Yshift([out, retval] double* Value);
    [propput, id(0x000000D3)]
    HRESULT _stdcall Yshift([in] double Value);
    [propget, id(0x000000D4), helpstring("Factor to scale X values from original curve")]
    HRESULT _stdcall Xscale([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Factor to scale X values from original curve")]
    HRESULT _stdcall Xscale([in] double Value);
    [propget, id(0x000000D5), helpstring("Factor to scale Y values from original curve")]
    HRESULT _stdcall Yscale([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("Amount to scale Y values from original curve. Represents a curve shift.")]
    HRESULT _stdcall Yscale([in] double Value);
  };

  [
    uuid(05D4E15E-1588-4ABB-8339-3527420C668B),
    helpstring("Dispatch interface for PDElements Object"),
    dual,
    oleautomation
  ]
  interface IPDElements: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of PD elements (including disabled elements)")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Set the first enabled PD element to be the active element.  Returns 0 if none found.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Advance to the next PD element in the circuit. Enabled elements only. Returns 0 when no more elements.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Variant boolean indicating of PD element should be treated as a shunt element rather than a series element. Applies to Capacitor and Reactor elements in particular.")]
    HRESULT _stdcall IsShunt([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000CD), helpstring("Get/Set Number of failures per year. For LINE elements: Number of failures per unit length per year. ")]
    HRESULT _stdcall FaultRate([out, retval] double* Value);
    [propput, id(0x000000CD)]
    HRESULT _stdcall FaultRate([in] double Value);
    [propget, id(0x000000CE), helpstring("Get/Set percent of faults that are permanent (require repair). Otherwise, fault is assumed to be transient/temporary.")]
    HRESULT _stdcall pctPermanent([out, retval] double* Value);
    [propput, id(0x000000CE)]
    HRESULT _stdcall pctPermanent([in] double Value);
    [propget, id(0x000000CF), helpstring("Get/Set name of active PD Element. Returns null string if active element is not PDElement type.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000D0), helpstring("Failure rate for this branch. Faults per year including length of line.")]
    HRESULT _stdcall Lambda([out, retval] double* Value);
    [propget, id(0x000000D1), helpstring("accummulated failure rate for this branch on downline")]
    HRESULT _stdcall AccumulatedL([out, retval] double* Value);
    [propget, id(0x000000D3), helpstring("Number of customers, this branch")]
    HRESULT _stdcall Numcustomers([out, retval] long* Value);
    [propget, id(0x000000D4), helpstring("Total number of customers from this branch to the end of the zone")]
    HRESULT _stdcall Totalcustomers([out, retval] long* Value);
    [propget, id(0x000000D5), helpstring("Sets the parent PD element to be the active circuit element.  Returns 0 if no more elements upline.")]
    HRESULT _stdcall ParentPDElement([out, retval] long* Value);
    [propget, id(0x000000D6), helpstring("Number of the terminal of active PD element that is on the \"from\" side. This is set after the meter zone is determined.")]
    HRESULT _stdcall FromTerminal([out, retval] long* Value);
    [propget, id(0x000000D7), helpstring("Total miles of line from this element to the end of the zone. For recloser siting algorithm.")]
    HRESULT _stdcall TotalMiles([out, retval] double* Value);
    [propget, id(0x000000D8), helpstring("Integer ID of the feeder section that this PDElement branch is part of")]
    HRESULT _stdcall SectionID([out, retval] long* Value);
    [propget, id(0x000000D2), helpstring("Average repair time for this element in hours")]
    HRESULT _stdcall RepairTime([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("Average repair time for this element in hours")]
    HRESULT _stdcall RepairTime([in] double Value);
  };

  [
    uuid(21001789-9F46-4323-93B0-8B31395FD6E4),
    helpstring("Dispatch interface for Reclosers Object"),
    dual,
    oleautomation
  ]
  interface IReclosers: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings with names of all Reclosers in Active Circuit")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Number of Reclosers in active circuit.")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Set First Recloser to be Active Ckt Element. Returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Iterate to the next recloser in the circuit. Returns zero if no more.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Get Name of active Recloser or set the active Recloser by name.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CD)]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Full name of object this Recloser is monitoring.")]
    HRESULT _stdcall MonitoredObj([out, retval] BSTR* Value);
    [propput, id(0x000000CE), helpstring("Set monitored object by full name.")]
    HRESULT _stdcall MonitoredObj([in] BSTR Value);
    [propget, id(0x000000CF), helpstring("Terminal number of Monitored object for the Recloser ")]
    HRESULT _stdcall MonitoredTerm([out, retval] long* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall MonitoredTerm([in] long Value);
    [propget, id(0x000000D0), helpstring("Full name of the circuit element that is being switched by the Recloser.")]
    HRESULT _stdcall SwitchedObj([out, retval] BSTR* Value);
    [propput, id(0x000000D0)]
    HRESULT _stdcall SwitchedObj([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("Terminal number of the controlled device being switched by the Recloser")]
    HRESULT _stdcall SwitchedTerm([out, retval] long* Value);
    [propput, id(0x000000D1)]
    HRESULT _stdcall SwitchedTerm([in] long Value);
    [propget, id(0x000000D2), helpstring("Number of fast shots")]
    HRESULT _stdcall NumFast([out, retval] long* Value);
    [propput, id(0x000000D2)]
    HRESULT _stdcall NumFast([in] long Value);
    [propget, id(0x000000D3), helpstring("Number of shots to lockout (fast + delayed)")]
    HRESULT _stdcall Shots([out, retval] long* Value);
    [propput, id(0x000000D3)]
    HRESULT _stdcall Shots([in] long Value);
    [propget, id(0x000000D4), helpstring("Variant Array of Doubles: reclose intervals, s, between shots.")]
    HRESULT _stdcall RecloseIntervals([out, retval] VARIANT* Value);
    [propget, id(0x000000D5), helpstring("Phase trip curve multiplier or actual amps")]
    HRESULT _stdcall PhaseTrip([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("Phase Trip multiplier or actual amps")]
    HRESULT _stdcall PhaseTrip([in] double Value);
    [propget, id(0x000000D6), helpstring("Phase instantaneous curve multipler or actual amps")]
    HRESULT _stdcall PhaseInst([out, retval] double* Value);
    [propput, id(0x000000D6)]
    HRESULT _stdcall PhaseInst([in] double Value);
    [propget, id(0x000000D7), helpstring("Ground (3I0) trip multiplier or actual amps")]
    HRESULT _stdcall GroundTrip([out, retval] double* Value);
    [propput, id(0x000000D7)]
    HRESULT _stdcall GroundTrip([in] double Value);
    [propget, id(0x000000D8), helpstring("Ground (3I0) instantaneous trip setting - curve multipler or actual amps.")]
    HRESULT _stdcall GroundInst([out, retval] double* Value);
    [propput, id(0x000000D8), helpstring("Ground (3I0) trip instantaneous multiplier or actual amps")]
    HRESULT _stdcall GroundInst([in] double Value);
    [id(0x000000D9), helpstring("Open recloser's controlled element and lock out the recloser.")]
    HRESULT _stdcall Open(void);
    [id(0x000000DA), helpstring("Close the switched object controlled by the recloser. Resets recloser to first operation.")]
    HRESULT _stdcall Close(void);
    [propget, id(0x000000DB), helpstring("Get/Set the active Recloser by index into the recloser list.  1..Count")]
    HRESULT _stdcall idx([out, retval] long* Value);
    [propput, id(0x000000DB), helpstring("Get/Set the Active Recloser by index into the recloser list. 1..Count")]
    HRESULT _stdcall idx([in] long Value);
    [id(0x000000DC), helpstring("Reset recloser to normal state. If open, lock out the recloser. If closed, resets recloser to first operation.  ")]
    HRESULT _stdcall Reset(void);
    [propget, id(0x000000DD), helpstring("Get normal state of recloser.")]
    HRESULT _stdcall NormalState([out, retval] enum ActionCodes* Value);
    [propput, id(0x000000DD), helpstring("Set normal state of recloser.")]
    HRESULT _stdcall NormalState([in] enum ActionCodes Value);
    [propget, id(0x000000DE), helpstring("Get/Set present state of recloser. If set to open, open recloser's controlled element and lock out the recloser. If set to close, close recloser's controlled and resets recloser to first operation.")]
    HRESULT _stdcall State([out, retval] enum ActionCodes* Value);
    [propput, id(0x000000DE), helpstring("Set present state of recloser.")]
    HRESULT _stdcall State([in] enum ActionCodes Value);
  };

  [
    uuid(76956697-6055-4E8E-B4D6-650805D3F90D),
    helpstring("Dispatch interface for Relays Object"),
    dual,
    oleautomation
  ]
  interface IRelays: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings containing names of all Relay elements")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Number of Relays in circuit")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Set First Relay active. If none, returns 0.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Advance to next Relay object. Returns 0 when no more relays.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Get name of active relay.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Set Relay active by name")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Full name of object this Relay is monitoring.")]
    HRESULT _stdcall MonitoredObj([out, retval] BSTR* Value);
    [propput, id(0x000000CE)]
    HRESULT _stdcall MonitoredObj([in] BSTR Value);
    [propget, id(0x000000CF), helpstring("Number of terminal of monitored element that this Relay is monitoring.")]
    HRESULT _stdcall MonitoredTerm([out, retval] long* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall MonitoredTerm([in] long Value);
    [propget, id(0x000000D0), helpstring("Full name of element that will be switched when relay trips.")]
    HRESULT _stdcall SwitchedObj([out, retval] BSTR* Value);
    [propput, id(0x000000D0)]
    HRESULT _stdcall SwitchedObj([in] BSTR Value);
    [propget, id(0x000000D1)]
    HRESULT _stdcall SwitchedTerm([out, retval] long* Value);
    [propput, id(0x000000D1), helpstring("Terminal number of the switched object that will be opened when the relay trips.")]
    HRESULT _stdcall SwitchedTerm([in] long Value);
    [propget, id(0x000000D2), helpstring("Get/Set active Relay by index into the Relay list. 1..Count")]
    HRESULT _stdcall idx([out, retval] long* Value);
    [propput, id(0x000000D2), helpstring("Get/Set Relay active by index into relay list. 1..Count")]
    HRESULT _stdcall idx([in] long Value);
  };

  [
    uuid(2B649EC0-FA89-45ED-A937-E7CB47806A3A),
    helpstring("Dispatch interface for CmathLib Object"),
    dual,
    oleautomation
  ]
  interface ICmathLib: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Convert real and imaginary doubles to Variant array of doubles")]
    HRESULT _stdcall cmplx([in] double RealPart, [in] double ImagPart, [out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Return abs value of complex number given in real and imag doubles")]
    HRESULT _stdcall cabs([in] double realpart, [in] double imagpart, [out, retval] double* Value);
    [propget, id(0x000000CB), helpstring("Returns the angle, in degrees, of a complex number specified as two doubles: Realpart and imagpart.")]
    HRESULT _stdcall cdang([in] double RealPart, [in] double ImagPart, [out, retval] double* Value);
    [propget, id(0x000000CC), helpstring("Convert complex number to magnitude and angle, degrees. Returns variant array of two doubles.")]
    HRESULT _stdcall ctopolardeg([in] double RealPart, [in] double ImagPart, [out, retval] VARIANT* Value);
    [propget, id(0x000000CD), helpstring("Convert magnitude, angle in degrees to a complex number. Returns Variant array of two doubles.")]
    HRESULT _stdcall pdegtocomplex([in] double magnitude, [in] double angle, [out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("Multiply two complex numbers: (a1, b1) * (a2, b2). Returns result as a variant array of two doubles.")]
    HRESULT _stdcall cmul([in] double a1, [in] double b1, [in] double a2, [in] double b2, [out, retval] VARIANT* Value);
    [propget, id(0x000000CF), helpstring("Divide two complex number: (a1, b1)/(a2, b2). Returns variant array of two doubles representing complex result.")]
    HRESULT _stdcall cdiv([in] double a1, [in] double b1, [in] double a2, [in] double b2, [out, retval] VARIANT* Value);
  };

  [
    uuid(9714FED4-9D39-4692-B76B-9A18F206A934),
    helpstring("Dispatch interface for Parser Object"),
    dual,
    oleautomation
  ]
  interface IParser: IDispatch
  {
    [propget, id(0x000000C9), helpstring("String to be parsed. Loading this string resets the Parser to the beginning of the line. Then parse off the tokens in sequence.")]
    HRESULT _stdcall CmdString([out, retval] BSTR* Value);
    [propput, id(0x000000C9), helpstring("String to be parsed. Loading this string resets the Parser to the beginning of the line. Then parse off the tokens in sequence.")]
    HRESULT _stdcall CmdString([in] BSTR Value);
    [propget, id(0x000000CA), helpstring("Get next token and return tag name (before = sign) if any. See AutoIncrement.")]
    HRESULT _stdcall NextParam([out, retval] BSTR* Value);
    [propget, id(0x000000CB), helpstring("Default is FALSE. If TRUE parser automatically advances to next token after DblValue, IntValue, or StrValue. Simpler when you don't need to check for parameter names.")]
    HRESULT _stdcall AutoIncrement([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CB), helpstring("Default is FALSE. If TRUE parser automatically advances to next token after DblValue, IntValue, or StrValue. Simpler when you don't need to check for parameter names.")]
    HRESULT _stdcall AutoIncrement([in] VARIANT_BOOL Value);
    [propget, id(0x000000CC), helpstring("Return next parameter as a double.")]
    HRESULT _stdcall DblValue([out, retval] double* Value);
    [propget, id(0x000000CD), helpstring("Return next parameter as a long integer.")]
    HRESULT _stdcall IntValue([out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Return next parameter as a string")]
    HRESULT _stdcall StrValue([out, retval] BSTR* Value);
    [propget, id(0x000000CF), helpstring("Get the characters used for White space in the command string.  Default is blank and Tab.")]
    HRESULT _stdcall WhiteSpace([out, retval] BSTR* Value);
    [propput, id(0x000000CF), helpstring("Set the characters used for White space in the command string.  Default is blank and Tab.")]
    HRESULT _stdcall WhiteSpace([in] BSTR Value);
    [propget, id(0x000000D0), helpstring("Get String containing the the characters for Quoting in OpenDSS scripts. Matching pairs defined in EndQuote. Default is \"'([{.")]
    HRESULT _stdcall BeginQuote([out, retval] BSTR* Value);
    [propput, id(0x000000D0), helpstring("Set String containing the the characters for Quoting in OpenDSS scripts. Matching pairs defined in EndQuote. Default is \"'([{.")]
    HRESULT _stdcall BeginQuote([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("String containing characters, in order, that match the beginning quote characters in BeginQuote. Default is \"')]}")]
    HRESULT _stdcall EndQuote([out, retval] BSTR* Value);
    [propput, id(0x000000D1), helpstring("String containing characters, in order, that match the beginning quote characters in BeginQuote. Default is \"')]}")]
    HRESULT _stdcall EndQuote([in] BSTR Value);
    [propget, id(0x000000D2), helpstring("String defining hard delimiters used to separate token on the command string. Default is , and =. The = separates token name from token value. These override whitesspace to separate tokens.")]
    HRESULT _stdcall Delimiters([out, retval] BSTR* Value);
    [propput, id(0x000000D2), helpstring("String defining hard delimiters used to separate token on the command string. Default is , and =. The = separates token name from token value. These override whitesspace to separate tokens.")]
    HRESULT _stdcall Delimiters([in] BSTR Value);
    [id(0x000000D3), helpstring("Reset delimiters to their default values.")]
    HRESULT _stdcall ResetDelimiters(void);
    [propget, id(0x000000D4), helpstring("Returns token as variant array of doubles. For parsing quoted array syntax.")]
    HRESULT _stdcall Vector([in] long ExpectedSize, [out, retval] VARIANT* Value);
    [propget, id(0x000000D5), helpstring("Use this property to parse a Matrix token in OpenDSS format.  Returns square matrix of order specified. Order same as default Fortran order: column by column.")]
    HRESULT _stdcall Matrix([in] long ExpectedOrder, [out, retval] VARIANT* Value);
    [propget, id(0x000000D6), helpstring("Use this property to parse a matrix token specified in lower triangle form. Symmetry is forced.")]
    HRESULT _stdcall SymMatrix([in] long ExpectedOrder, [out, retval] VARIANT* Value);
  };

  [
    uuid(196861FB-38C6-4FB4-B8A5-B2DDA3DDA663),
    helpstring("Dispatch interface for LoadShapes Object"),
    dual,
    oleautomation
  ]
  interface ILoadShapes: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Get the Name of the active Loadshape")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000C9), helpstring("Set the active Loadshape by name")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CA), helpstring("Number of Loadshape objects currently defined in Loadshape collection")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Set the first loadshape active and return integer index of the loadshape. Returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Advance active Loadshape to the next on in the collection. Returns 0 if no more loadshapes.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Variant array of strings containing names of all Loadshape objects currently defined.")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("Get Number of points in active Loadshape.")]
    HRESULT _stdcall Npts([out, retval] long* Value);
    [propput, id(0x000000CE), helpstring("Set number of points to allocate for active Loadshape.")]
    HRESULT _stdcall Npts([in] long Value);
    [propget, id(0x000000CF), helpstring("Variant array of Doubles for the P multiplier in the Loadshape.")]
    HRESULT _stdcall Pmult([out, retval] VARIANT* Value);
    [propput, id(0x000000CF), helpstring("Variant array of doubles containing the P array for the Loadshape.")]
    HRESULT _stdcall Pmult([in] VARIANT Value);
    [propget, id(0x000000D0), helpstring("Variant array of doubles containing the Q multipliers.")]
    HRESULT _stdcall Qmult([out, retval] VARIANT* Value);
    [propput, id(0x000000D0), helpstring("Variant array of doubles containing the Q multipliers.")]
    HRESULT _stdcall Qmult([in] VARIANT Value);
    [id(0x000000D1), helpstring("Normalize the P and Q curves based on either Pbase, Qbase or simply the peak value of the curve.")]
    HRESULT _stdcall Normalize(void);
    [propget, id(0x000000D2), helpstring("Time array in hours correscponding to P and Q multipliers when the Interval=0.")]
    HRESULT _stdcall TimeArray([out, retval] VARIANT* Value);
    [propput, id(0x000000D2), helpstring("Time array in hours correscponding to P and Q multipliers when the Interval=0.")]
    HRESULT _stdcall TimeArray([in] VARIANT Value);
    [propget, id(0x000000D3), helpstring("Fixed interval time value, hours")]
    HRESULT _stdcall HrInterval([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Fixed interval time value, hours.")]
    HRESULT _stdcall HrInterval([in] double Value);
    [propget, id(0x000000D4), helpstring("Fixed Interval time value, in minutes")]
    HRESULT _stdcall MinInterval([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Fixed Interval time value, in minutes")]
    HRESULT _stdcall MinInterval([in] double Value);
    [id(0x000000D6), helpstring("Make a new Loadshape")]
    long _stdcall New([in] BSTR Name);
    [propget, id(0x000000D7), helpstring("Base for normalizing P curve. If left at zero, the peak value is used.")]
    HRESULT _stdcall Pbase([out, retval] double* Value);
    [propput, id(0x000000D7), helpstring("Base for normalizing P curve. If left at zero, the peak value is used.")]
    HRESULT _stdcall Pbase([in] double Value);
    [propget, id(0x000000D8), helpstring("Base for normalizing Q curve. If left at zero, the peak value is used.")]
    HRESULT _stdcall Qbase([out, retval] double* Value);
    [propput, id(0x000000D8), helpstring("Base for normalizing Q curve. If left at zero, the peak value is used.")]
    HRESULT _stdcall Qbase([in] double Value);
    [propget, id(0x000000D9), helpstring("T/F flag to let Loads know to use the actual value in the curve rather than use the value as a multiplier.")]
    HRESULT _stdcall UseActual([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D9), helpstring("T/F flag to let Loads know to use the actual value in the curve rather than use the value as a multiplier.")]
    HRESULT _stdcall UseActual([in] VARIANT_BOOL Value);
    [propget, id(0x000000D5), helpstring("Fixed interval data time interval, seconds")]
    HRESULT _stdcall Sinterval([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("Fixed interval data time interval, seconds")]
    HRESULT _stdcall Sinterval([in] double Value);
  };

  [
    uuid(AABE4DA8-3D5A-447F-AFFB-78946BA68DA5),
    helpstring("Dispatch interface for Fuses Object"),
    dual,
    oleautomation
  ]
  interface IFuses: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings containing names of all Fuses in the circuit")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Number of Fuse elements in the circuit")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Set the first Fuse to be the active fuse. Returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Advance the active Fuse element pointer to the next fuse. Returns 0 if no more fuses.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Get the name of the active Fuse element")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Set the active Fuse element by name.")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Full name of the circuit element to which the fuse is connected.")]
    HRESULT _stdcall MonitoredObj([out, retval] BSTR* Value);
    [propput, id(0x000000CE), helpstring("Full name of the circuit element to which the fuse is connected.")]
    HRESULT _stdcall MonitoredObj([in] BSTR Value);
    [propget, id(0x000000CF), helpstring("Terminal number to which the fuse is connected.")]
    HRESULT _stdcall MonitoredTerm([out, retval] long* Value);
    [propput, id(0x000000CF), helpstring("Number of the terminal to which the fuse is connected")]
    HRESULT _stdcall MonitoredTerm([in] long Value);
    [propget, id(0x000000D0), helpstring("Full name of the circuit element switch that the fuse controls. Defaults to the MonitoredObj.")]
    HRESULT _stdcall SwitchedObj([out, retval] BSTR* Value);
    [propput, id(0x000000D0), helpstring("Full name of the circuit element switch that the fuse controls. Defaults to MonitoredObj.")]
    HRESULT _stdcall SwitchedObj([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("Number of the terminal containing the switch controlled by the fuse.")]
    HRESULT _stdcall SwitchedTerm([out, retval] long* Value);
    [propput, id(0x000000D1), helpstring("Number of the terminal of the controlled element containing the switch controlled by the fuse.")]
    HRESULT _stdcall SwitchedTerm([in] long Value);
    [propget, id(0x000000D2), helpstring("Name of the TCCcurve object that determines fuse blowing.")]
    HRESULT _stdcall TCCcurve([out, retval] BSTR* Value);
    [propput, id(0x000000D2), helpstring("Name of the TCCcurve object that determines fuse blowing.")]
    HRESULT _stdcall TCCcurve([in] BSTR Value);
    [propget, id(0x000000D3), helpstring("Multiplier or actual amps for the TCCcurve object. Defaults to 1.0.  Multipliy current values of TCC curve by this to get actual amps.")]
    HRESULT _stdcall RatedCurrent([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Multiplier or actual fuse amps for the TCC curve. Defaults to 1.0. Has to correspond to the Current axis of TCCcurve object.")]
    HRESULT _stdcall RatedCurrent([in] double Value);
    [propget, id(0x000000D4), helpstring("A fixed delay time in seconds added to the fuse blowing time determined by the TCC curve. Default is 0.")]
    HRESULT _stdcall Delay([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Fixed delay time in seconds added to the fuse blowing time to represent fuse clear or other delay.")]
    HRESULT _stdcall Delay([in] double Value);
    [id(0x000000D5), helpstring("Manual opening of all phases of the fuse.")]
    HRESULT _stdcall Open(void);
    [id(0x000000D6), helpstring("Close all phases of the fuse.")]
    HRESULT _stdcall Close(void);
    [id(0x000000D7), helpstring("Current state of the fuses. TRUE if any fuse on any phase is blown. Else FALSE.")]
    VARIANT_BOOL _stdcall IsBlown(void);
    [propget, id(0x000000D8), helpstring("Get/set active fuse by index into the list of fuses. 1 based: 1..count")]
    HRESULT _stdcall idx([out, retval] long* Value);
    [propput, id(0x000000D8), helpstring("Set Fuse active by index into the list of fuses. 1..count")]
    HRESULT _stdcall idx([in] long Value);
    [propget, id(0x000000D9), helpstring("Number of phases, this fuse. ")]
    HRESULT _stdcall NumPhases([out, retval] long* Value);
    [id(0x000000DA), helpstring("Reset fuse to normal state.")]
    HRESULT _stdcall Reset(void);
    [propget, id(0x000000DB), helpstring("Variant array of strings indicating the state of each phase of the fuse. 0-based array.")]
    HRESULT _stdcall State([out, retval] VARIANT* Value);
    [propput, id(0x000000DB), helpstring("Variant array of strings. Set state of each phase of the fuse.\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall State([in] VARIANT Value);
    [propget, id(0x000000DC), helpstring("Variant array of strings indicating the normal state of each phase of the fuse. 0-based array.")]
    HRESULT _stdcall NormalState([out, retval] VARIANT* Value);
    [propput, id(0x000000DC), helpstring("Variant array of strings. Set normal state of each phase of the fuse.\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormalState([in] VARIANT Value);
  };

  [
    uuid(CB2C7310-1717-4C6E-A7B8-DA54CF1722CD),
    helpstring("Dispatch interface for ISources Object"),
    dual,
    oleautomation
  ]
  interface IISources: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings containing names of all ISOURCE elements.")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Count: Number of ISOURCE elements.")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Set the First ISOURCE to be active; returns Zero if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next ISOURCE element to be the active one. Returns Zero if no more.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Get name of active ISOURCE")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Set Active ISOURCE by name")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Get the magnitude of the ISOURCE in amps")]
    HRESULT _stdcall Amps([out, retval] double* Value);
    [propput, id(0x000000CE), helpstring("Set the magnitude of the ISOURCE, amps")]
    HRESULT _stdcall Amps([in] double Value);
    [propget, id(0x000000CF), helpstring("Phase angle for ISOURCE, degrees")]
    HRESULT _stdcall AngleDeg([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Phase angle for ISOURCE, degrees")]
    HRESULT _stdcall AngleDeg([in] double Value);
    [propget, id(0x000000D0), helpstring("The present frequency of the ISOURCE, Hz")]
    HRESULT _stdcall Frequency([out, retval] double* Value);
    [propput, id(0x000000D0), helpstring("Set the present frequency for the ISOURCE")]
    HRESULT _stdcall Frequency([in] double Value);
  };

  [
    uuid(25C5373D-5888-4A0C-974B-77EBD57ED0D1),
    helpstring("Used for communicating directly with DSSim and to extract some specific info"),
    dual,
    oleautomation
  ]
  interface IDSSimComs: IDispatch
  {
    [id(0x000000CA), helpstring("This method delivers the voltage pu of the specified bus, this specification must be with a number (index)")]
    HRESULT _stdcall BusVoltagepu([in] unsigned int Index, [out, retval] VARIANT* Vpu);
    [id(0x000000CB), helpstring("This method delivers the voltage (complex) of the specified bus, this specification must be with a number (index)")]
    HRESULT _stdcall BusVoltage([in] unsigned int Index, [out, retval] VARIANT* Voltages);
  };

  [
    uuid(FAF19717-5887-43F6-8DC3-D0337E1081AD),
    helpstring("Dispatch interface for PVSystems Object"),
    dual,
    oleautomation
  ]
  interface IPVSystems: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Vairant array of strings with all PVSystem names")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Variant Array of PVSYSTEM energy meter register names")]
    HRESULT _stdcall RegisterNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CB), helpstring("Variant array of doubles containing values in PVSystem registers.")]
    HRESULT _stdcall RegisterValues([out, retval] VARIANT* Value);
    [propget, id(0x000000CC), helpstring("Set first PVSystem active; returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Sets next PVSystem active; returns 0 if no more.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Number of PVSystems")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CF), helpstring("Get/set active PVSystem by index;  1..Count")]
    HRESULT _stdcall idx([out, retval] long* Value);
    [propput, id(0x000000CF), helpstring("Get/Set Active PVSystem by index:  1.. Count")]
    HRESULT _stdcall idx([in] long Value);
    [propget, id(0x000000D0), helpstring("Get the name of the active PVSystem")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000D0), helpstring("Set the name of the active PVSystem")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("Get the present value of the Irradiance property in W/sq-m")]
    HRESULT _stdcall Irradiance([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Set the present Irradiance value in W/sq-m")]
    HRESULT _stdcall Irradiance([in] double Value);
    [propget, id(0x000000D2), helpstring("get kW output")]
    HRESULT _stdcall kW([out, retval] double* Value);
    [propget, id(0x000000D3), helpstring("Get kvar value")]
    HRESULT _stdcall kvar([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Set kvar output value")]
    void _stdcall kvar([in] double Value);
    [propget, id(0x000000D4), helpstring("Get Power factor ")]
    HRESULT _stdcall PF([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Set PF ")]
    void _stdcall PF([in] double Value);
    [propget, id(0x000000D5), helpstring("Get Rated kVA of the PVSystem")]
    HRESULT _stdcall kVArated([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("Set kva rated")]
    void _stdcall kVArated([in] double Value);
    [propget, id(0x000000D6), helpstring("Gets the rated max power of the PV array for 1.0 kW/sq-m irradiance and a user-selected array temperature of the active PVSystem.")]
    HRESULT _stdcall Pmpp([out, retval] double* Value);
    [propput, id(0x000000D6), helpstring("Sets the rated max power of the PV array for 1.0 kW/sq-m irradiance and a user-selected array temperature of the active PVSystem.")]
    HRESULT _stdcall Pmpp([in] double Value);
    [propget, id(0x000000D7), helpstring("Returns the current irradiance value for the active PVSystem. Use it to know what's the current irradiance value for the PV during a simulation.")]
    HRESULT _stdcall IrradianceNow([out, retval] double* Value);
  };

  [
    uuid(8DCD1962-268B-40E1-B49E-B7C01C3E07CD),
    helpstring("Dispatch interface for Vsources Object"),
    dual,
    oleautomation
  ]
  interface IVsources: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Names of all Vsource objects in the circuit")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Number of Vsource Object")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets the first VSOURCE to be active; Returns 0 if none")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next VSOURCE object to be active; returns zero if no more")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Get Active VSOURCE name")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Set Active VSOURCE by Name")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Source Voltage in kV")]
    HRESULT _stdcall BasekV([out, retval] double* Value);
    [propput, id(0x000000CE), helpstring("Source voltage in kV")]
    HRESULT _stdcall BasekV([in] double Value);
    [propget, id(0x000000CF), helpstring("Source pu voltage.")]
    HRESULT _stdcall pu([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Per-unit value of source voltage based on kV")]
    HRESULT _stdcall pu([in] double Value);
    [propget, id(0x000000D0), helpstring("Phase angle of first phase in degrees")]
    HRESULT _stdcall AngleDeg([out, retval] double* Value);
    [propput, id(0x000000D0), helpstring("phase angle in degrees")]
    HRESULT _stdcall AngleDeg([in] double Value);
    [propget, id(0x000000D1), helpstring("Source Frequency in Hz")]
    HRESULT _stdcall Frequency([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Source frequency in Hz")]
    HRESULT _stdcall Frequency([in] double Value);
    [propget, id(0x000000D2), helpstring("Number of Phases")]
    HRESULT _stdcall Phases([out, retval] long* Value);
    [propput, id(0x000000D2), helpstring("Number of phases")]
    HRESULT _stdcall Phases([in] long Value);
  };

  [
    uuid(A0351633-A988-4A5B-B551-A7E2ADDD4984),
    helpstring("Dispatch to control parallel computations on OpenDSS"),
    dual,
    oleautomation
  ]
  interface IParallel: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Delivers the number of CPUs on the current PC")]
    HRESULT _stdcall NumCPUs([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Delivers the number of Cores of the local PC")]
    HRESULT _stdcall NumCores([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Gets the ID of the Active Actor")]
    HRESULT _stdcall ActiveActor([out, retval] long* Value);
    [propput, id(0x000000CB), helpstring("Sets the Active Actor")]
    HRESULT _stdcall ActiveActor([in] long Value);
    [id(0x000000CC), helpstring("Creates a New Actor")]
    HRESULT _stdcall CreateActor(void);
    [propget, id(0x000000CD), helpstring("Gets the CPU of the Active Actor")]
    HRESULT _stdcall ActorCPU([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("Sets the CPU for the Active Actor")]
    HRESULT _stdcall ActorCPU([in] long Value);
    [propget, id(0x000000CE), helpstring("Gets the number of Actors created")]
    HRESULT _stdcall NumOfActors([out, retval] long* Value);
    [id(0x000000CF), helpstring("Waits until all actors have finised their tasks")]
    HRESULT _stdcall Wait(void);
    [propget, id(0x000000D0), helpstring("Gets the progress of all existing actors in pct")]
    HRESULT _stdcall ActorProgress([out, retval] VARIANT* Value);
    [propget, id(0x000000D1), helpstring("Gets the status of each actor")]
    HRESULT _stdcall ActorStatus([out, retval] VARIANT* Value);
    [propget, id(0x000000D2), helpstring("Sets ON/OFF (1/0) Parallel features of the Engine")]
    HRESULT _stdcall ActiveParallel([out, retval] long* Value);
    [propput, id(0x000000D2), helpstring("Delivers if the Parallel features of the Engine are Active")]
    HRESULT _stdcall ActiveParallel([in] long Value);
    [propget, id(0x000000D3), helpstring("Reads the values of the ConcatenateReports option (1=enabled, 0=disabled)")]
    HRESULT _stdcall ConcatenateReports([out, retval] long* Value);
    [propput, id(0x000000D3), helpstring("Enable/Disable (1/0) the ConcatenateReports option for extracting monitors data")]
    HRESULT _stdcall ConcatenateReports([in] long Value);
  };

  [
    uuid(43140E77-9EA6-4156-A686-ABFAFFE8A059),
    helpstring("Dispatch interface for LineCodes Object"),
    dual,
    oleautomation
  ]
  interface ILineCodes: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of LineCodes")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CA)]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CB)]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Name of active LineCode")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CC)]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("Flag denoting whether impedance data were entered in symmetrical components")]
    HRESULT _stdcall IsZ1Z0([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000CE)]
    HRESULT _stdcall Units([out, retval] long* Value);
    [propput, id(0x000000CE)]
    HRESULT _stdcall Units([in] long Value);
    [propget, id(0x000000CF), helpstring("Number of Phases")]
    HRESULT _stdcall Phases([out, retval] long* Value);
    [propput, id(0x000000CF), helpstring("Number of Phases")]
    HRESULT _stdcall Phases([in] long Value);
    [propget, id(0x000000D1), helpstring("Positive-sequence resistance ohms per unit length")]
    HRESULT _stdcall R1([out, retval] double* Value);
    [propput, id(0x000000D1)]
    HRESULT _stdcall R1([in] double Value);
    [propget, id(0x000000D0), helpstring("Posiive-sequence reactance, ohms per unit length")]
    HRESULT _stdcall X1([out, retval] double* Value);
    [propput, id(0x000000D0)]
    HRESULT _stdcall X1([in] double Value);
    [propget, id(0x000000D2), helpstring("Zero-Sequence Resistance, ohms per unit length")]
    HRESULT _stdcall R0([out, retval] double* Value);
    [propput, id(0x000000D2)]
    HRESULT _stdcall R0([in] double Value);
    [propget, id(0x000000D3), helpstring("Zero Sequence Reactance, Ohms per unit length")]
    HRESULT _stdcall X0([out, retval] double* Value);
    [propput, id(0x000000D3)]
    HRESULT _stdcall X0([in] double Value);
    [propget, id(0x000000D4), helpstring("Positive-sequence capacitance, nF per unit length")]
    HRESULT _stdcall C1([out, retval] double* Value);
    [propput, id(0x000000D4)]
    HRESULT _stdcall C1([in] double Value);
    [propget, id(0x000000D5), helpstring("Zero-sequence capacitance, nF per unit length")]
    HRESULT _stdcall C0([out, retval] double* Value);
    [propput, id(0x000000D5)]
    HRESULT _stdcall C0([in] double Value);
    [propget, id(0x000000D6), helpstring("Resistance matrix, ohms per unit length")]
    HRESULT _stdcall Rmatrix([out, retval] VARIANT* Value);
    [propput, id(0x000000D6)]
    HRESULT _stdcall Rmatrix([in] VARIANT Value);
    [propget, id(0x000000D7), helpstring("Reactance matrix, ohms per unit length")]
    HRESULT _stdcall Xmatrix([out, retval] VARIANT* Value);
    [propput, id(0x000000D7)]
    HRESULT _stdcall Xmatrix([in] VARIANT Value);
    [propget, id(0x000000D8), helpstring("Capacitance matrix, nF per unit length")]
    HRESULT _stdcall Cmatrix([out, retval] VARIANT* Value);
    [propput, id(0x000000D8)]
    HRESULT _stdcall Cmatrix([in] VARIANT Value);
    [propget, id(0x000000D9), helpstring("Normal Ampere rating")]
    HRESULT _stdcall NormAmps([out, retval] double* Value);
    [propput, id(0x000000D9)]
    HRESULT _stdcall NormAmps([in] double Value);
    [propget, id(0x000000DA), helpstring("Emergency ampere rating")]
    HRESULT _stdcall EmergAmps([out, retval] double* Value);
    [propput, id(0x000000DA)]
    HRESULT _stdcall EmergAmps([in] double Value);
    [propget, id(0x000000DB), helpstring("Variant array of strings with names of all devices")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
  };

  [
    uuid(F76B5BDE-9132-44FB-8115-70BF1B065FA4),
    helpstring("Dispatch interface for GICSources Object"),
    dual,
    oleautomation
  ]
  interface IGICSources: IDispatch
  {
    [propget, id(0x000000C9), helpstring("All GICSourceNames")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("First bus name of GICSource (Created name)")]
    HRESULT _stdcall Bus1([out, retval] BSTR* Value);
    [propget, id(0x000000CB), helpstring("Second bus name")]
    HRESULT _stdcall Bus2([out, retval] BSTR* Value);
    [propget, id(0x000000CC)]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CC)]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CD)]
    HRESULT _stdcall Phases([out, retval] long* Value);
    [propput, id(0x000000CD)]
    HRESULT _stdcall Phases([in] long Value);
    [propget, id(0x000000CE), helpstring("Northward E Field V/km")]
    HRESULT _stdcall EN([out, retval] double* Value);
    [propput, id(0x000000CE)]
    HRESULT _stdcall EN([in] double Value);
    [propget, id(0x000000CF), helpstring("Eastward E Field, V/km")]
    HRESULT _stdcall EE([out, retval] double* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall EE([in] double Value);
    [propget, id(0x000000D0), helpstring("Latitude of Bus1 (degrees)")]
    HRESULT _stdcall Lat1([out, retval] double* Value);
    [propput, id(0x000000D0)]
    HRESULT _stdcall Lat1([in] double Value);
    [propget, id(0x000000D1), helpstring("Latitude of Bus2 (degrees)")]
    HRESULT _stdcall Lat2([out, retval] double* Value);
    [propput, id(0x000000D1)]
    HRESULT _stdcall Lat2([in] double Value);
    [propget, id(0x000000D2), helpstring("Longitude of Bus1")]
    HRESULT _stdcall Lon1([out, retval] double* Value);
    [propput, id(0x000000D2)]
    HRESULT _stdcall Lon1([in] double Value);
    [propget, id(0x000000D3), helpstring("Longitude of Bus2 (Degrees)")]
    HRESULT _stdcall Lon2([out, retval] double* Value);
    [propput, id(0x000000D3)]
    HRESULT _stdcall Lon2([in] double Value);
    [propget, id(0x000000D4), helpstring("Specify dc voltage directly")]
    HRESULT _stdcall Volts([out, retval] double* Value);
    [propput, id(0x000000D4)]
    HRESULT _stdcall Volts([in] double Value);
    [propget, id(0x000000D5)]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000D6), helpstring("Set first GIC Source Active")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000D7), helpstring("Set Next GICSource Active")]
    HRESULT _stdcall Next([out, retval] long* Value);
  };

  [
    uuid(02386435-8D77-4804-8ADB-89DDFBBE2BC0),
    helpstring("Dispatch interface for Reduce Object"),
    dual,
    oleautomation
  ]
  interface IReduceCkt: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Zmag for Short Line Reduction Algorithm")]
    HRESULT _stdcall Zmag([out, retval] double* Value);
    [propput, id(0x000000C9), helpstring("Zmag (ohms) for Reduce Option for Z of short lines")]
    HRESULT _stdcall Zmag([in] double Value);
    [propget, id(0x000000CA), helpstring("Keep load flag (T/F) for Reduction options that remove branches")]
    HRESULT _stdcall KeepLoad([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CA), helpstring("Keep Load Flag (T/F) for  Reduction options that remove branches")]
    HRESULT _stdcall KeepLoad([in] VARIANT_BOOL Value);
    [propget, id(0x000000CB), helpstring("Edit String for Remove Branches function")]
    HRESULT _stdcall EditString([out, retval] BSTR* Value);
    [propput, id(0x000000CB), helpstring("Edit String for RemoveBranches functions")]
    HRESULT _stdcall EditString([in] BSTR Value);
    [propget, id(0x000000CC), helpstring("Start element for Remove Branch functions")]
    HRESULT _stdcall StartPDElement([out, retval] BSTR* Value);
    [propput, id(0x000000CC), helpstring("Start Element for Remove branch functions")]
    HRESULT _stdcall StartPDElement([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("Name of Energymeter to use for reduction")]
    HRESULT _stdcall EnergyMeter([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Name of Energymeter to use for reduction")]
    HRESULT _stdcall EnergyMeter([in] BSTR Value);
    [id(0x000000CE), helpstring("Save present (reduced) circuit")]
    HRESULT _stdcall SaveCircuit([in] BSTR CktName);
    [id(0x000000CF), helpstring("Do Default Reduction algorithm")]
    HRESULT _stdcall DoDefault(void);
    [id(0x000000D0), helpstring("Do ShortLines algorithm: Set Zmag first if you don't want the default")]
    HRESULT _stdcall DoShortLines(void);
    [id(0x000000D1), helpstring("Reduce Dangling Algorithm; branches with nothing connected")]
    HRESULT _stdcall DoDangling(void);
    [id(0x000000D2)]
    HRESULT _stdcall DoLoopBreak(void);
    [id(0x000000D3)]
    HRESULT _stdcall DoParallelLines(void);
    [id(0x000000D4)]
    HRESULT _stdcall DoSwitches(void);
    [id(0x000000D5), helpstring("Eliminate all 1-phase laterals in the circuit")]
    HRESULT _stdcall Do1phLaterals(void);
    [id(0x000000D6)]
    HRESULT _stdcall DoBranchRemove(void);
  };

  [
    uuid(AE501F77-F7F0-4201-A9AD-6AB385262203),
    helpstring("Events interface for DSSEvents Object")
  ]
  dispinterface IDSSEventsEvents
  {
    properties:
    methods:
    [id(0x000000C9), helpstring("Notification to initialize the control model.")]
    HRESULT InitControls(void);
    [id(0x000000CA), helpstring("Notification that a time step solution is complete, and the control should update itself.")]
    HRESULT StepControls(void);
    [id(0x000000CB), helpstring("Notification that a system solution has been performed, and controls should check and possibly create new events.")]
    HRESULT CheckControls(void);
  };

  [
    uuid(6E20BC4C-67C0-4AD3-9E12-BF90C478A1CC),
    version(1.0),
    helpstring("Text Object\0erface for Text Object\0\0e\0;\0p\x12\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Text
  {
    [default] interface IText;
  };

  [
    uuid(F8410F14-7E85-44A9-B42F-F900DF5F596E),
    version(1.0),
    helpstring("DSSProperty Object\0for DSSProperty Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSSProperty
  {
    [default] interface IDSSProperty;
  };

  [
    uuid(BC5F55A3-7A0F-4923-B218-098A91F482D8),
    version(1.0),
    helpstring("CktElementObject\0e for CktElement Object\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass CktElement
  {
    [default] interface ICktElement;
  };

  [
    uuid(0038D0EB-28ED-42B0-A247-E212E05ADF4B),
    version(1.0),
    helpstring("Error Object\0rface for Errror Object\0ect\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Error
  {
    [default] interface IError;
  };

  [
    uuid(B5B695B1-A1F5-444F-ABC5-836B7EF1DF0D),
    version(1.0),
    helpstring("Circuit Object\0ace for Circuit Object\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Circuit
  {
    [default] interface ICircuit;
  };

  [
    uuid(A14C32E4-846B-444D-9070-F7A31E9F5FF9),
    version(1.0),
    helpstring("Bus Object\0terface for Bus Object\0ect\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Bus
  {
    [default] interface IBus;
  };

  [
    uuid(6FE9D1B8-C064-4877-94C0-F13882ADBDB6),
    version(1.0),
    helpstring("DSS Main Object\0ce for DSSMain Object\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSS
  {
    [default] interface IDSS;
  };

  [
    uuid(F799E1DE-E7BF-4F86-BCED-6DD01FD00419),
    version(1.0),
    helpstring("Solution Object\0ce for Solution Object\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Solution
  {
    [default] interface ISolution;
  };

  [
    uuid(7FF93D6F-4258-40CB-9558-0792422309F3),
    version(1.0),
    helpstring("Monitors Object\0ce for Monitors Object\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Monitors
  {
    [default] interface IMonitors;
  };

  [
    uuid(F869D5BB-A023-48AB-A459-01444585B7C1),
    version(1.0),
    helpstring("Meters Object\0face for Meters Object\0t\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Meters
  {
    [default] interface IMeters;
  };

  [
    uuid(65F232C9-7D95-4E45-B9FA-40F518CFBB64),
    version(1.0),
    helpstring("Generators Object\0 for Generators Object\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Generators
  {
    [default] interface IGenerators;
  };

  [
    uuid(4CB900D9-DD2F-41AF-9E48-B999E0AED0A7),
    version(1.0),
    helpstring("DSSProgress Object\0for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSSProgress
  {
    [default] interface IDSSProgress;
  };

  [
    uuid(9D910AA4-0CB3-4907-AEEF-8DD79A58C0AD),
    version(1.0),
    helpstring("Settings Object\0ce for Settings Object\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Settings
  {
    [default] interface ISettings;
  };

  [
    uuid(A1352870-9D53-4E48-B83A-6DB0C8FED65B),
    version(1.0),
    helpstring("Lines Object\0rface for Lines Object\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Lines
  {
    [default] interface ILines;
  };

  [
    uuid(19DD7174-7FEE-4E59-97ED-C54F16EDC3F0),
    version(1.0),
    helpstring("CtrlQueue\0for CtrlQueue Object\0ject\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass CtrlQueue
  {
    [default] interface ICtrlQueue;
  };

  [
    uuid(1302A34B-A554-4C32-BCED-4AF0A94FF114),
    version(1.0),
    helpstring("Loads Object\0rface for Loads Object\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Loads
  {
    [default] interface ILoads;
  };

  [
    uuid(09D4B4AB-DF58-4F8F-A3F0-72F32830B337),
    version(1.0),
    helpstring("DSSElement Object\0 for DSSElement Object\0\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSSElement
  {
    [default] interface IDSSElement;
  };

  [
    uuid(2A02BB33-50A4-4C87-86E0-59EF7738F86C),
    version(1.0),
    helpstring("ActiveClass Object\0for ActiveClass Object\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass ActiveClass
  {
    [default] interface IActiveClass;
  };

  [
    uuid(F733F571-4CEC-45CC-922D-16C2BEEBA5BC),
    version(1.0),
    helpstring("\0\x01spatch interface for Capacitors\0 Object\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Capacitors
  {
    [default] interface ICapacitors;
  };

  [
    uuid(3A3E2154-1249-4DBB-AEDC-C4C14300D332),
    version(1.0),
    helpstring("\0\x01spatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Transformers
  {
    [default] interface ITransformers;
  };

  [
    uuid(7D8F53AE-0D61-4B87-9BEE-12D54052F689),
    version(1.0),
    helpstring("\0\x01spatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass SwtControls
  {
    [default] interface ISwtControls;
  };

  [
    uuid(7D95304E-B0A8-4531-8D1B-F438287EEA6E),
    version(1.0),
    helpstring("\0\x01spatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass CapControls
  {
    [default] interface ICapControls;
  };

  [
    uuid(D3DBDE53-6397-4C36-8C87-9BEA061FBC78),
    version(1.0),
    helpstring("\0\x01spatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass RegControls
  {
    [default] interface IRegControls;
  };

  [
    uuid(5B1B5AB3-0595-4E46-B64B-CF8877ED0857),
    version(1.0),
    helpstring("Topology Object\0ce for Topology Object\0\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Topology
  {
    [default] interface ITopology;
  };

  [
    uuid(D00898D0-6CC7-4A3B-BF89-DED9593579E7),
    version(1.0),
    helpstring("DSS_Executive Object\0r DSS_Executive Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSS_Executive
  {
    [default] interface IDSS_Executive;
  };

  [
    uuid(B734843A-08E4-42D3-9E24-C0D5F7BF6487),
    helpstring("DSSEvents Object")
  ]
  coclass DSSEvents
  {
    [default] interface IDSSEvents;
    [default, source] dispinterface IDSSEventsEvents;
  };

  [
    uuid(FC54E9AA-1C6A-4CF8-837D-82B257D98E5A),
    helpstring("Sensors Object")
  ]
  coclass Sensors
  {
    [default] interface ISensors;
  };

  [
    uuid(9594F37D-E47E-4701-892B-52BE7E576E87),
    helpstring("XYCurves Object")
  ]
  coclass XYCurves
  {
    [default] interface IXYCurves;
  };

  [
    uuid(4DDCDADD-A1D3-40BB-98E7-B023BD3947BE),
    helpstring("PDElements Object")
  ]
  coclass PDElements
  {
    [default] interface IPDElements;
  };

  [
    uuid(B92B059F-FEFD-4554-8F07-AFDCEFBBEA7B),
    helpstring("Reclosers Object")
  ]
  coclass Reclosers
  {
    [default] interface IReclosers;
  };

  [
    uuid(9D887EEA-7454-4214-BC56-AC42F5A3318E),
    helpstring("Relays Object")
  ]
  coclass Relays
  {
    [default] interface IRelays;
  };

  [
    uuid(76847D49-B650-4850-9486-E08B48F87E39),
    helpstring("CmathLib Object")
  ]
  coclass CmathLib
  {
    [default] interface ICmathLib;
  };

  [
    uuid(2245AD88-CB0E-4426-9DF2-5B2F89B2A08D),
    helpstring("Parser Object")
  ]
  coclass Parser
  {
    [default] interface IParser;
  };

  [
    uuid(4FCBE090-AA15-4E31-A8C7-E5F42D41C90C),
    helpstring("LoadShapes Object")
  ]
  coclass LoadShapes
  {
    [default] interface ILoadShapes;
  };

  [
    uuid(ABED90F5-3908-408A-87EF-D0582FD2FFD5),
    helpstring("Fuses Object")
  ]
  coclass Fuses
  {
    [default] interface IFuses;
  };

  [
    uuid(CE35EBD2-BDD4-4B01-AE88-1D90DC82F619),
    helpstring("ISource Object")
  ]
  coclass ISources
  {
    [default] interface IISources;
  };

  [
    uuid(2104B607-8D58-4BBD-85B8-4E5F1C8BD6BE),
    helpstring("DSSimComs Object")
  ]
  coclass DSSimComs
  {
    [default] interface IDSSimComs;
  };

  [
    uuid(D8D7592D-D5CD-4E27-870D-00D654DF2D3C),
    helpstring("PVSystems Object")
  ]
  coclass PVSystems
  {
    [default] interface IPVSystems;
  };

  [
    uuid(0823B8BD-AD34-452B-974A-F46BA25D49EA),
    helpstring("Vsources Object")
  ]
  coclass Vsources
  {
    [default] interface IVsources;
  };

  [
    uuid(D967764D-CD38-41ED-B1FD-7D79DC78EFCD)
  ]
  coclass Parallel
  {
    [default] interface IParallel;
  };

  [
    uuid(B6120B3A-7958-4650-AC18-2A53E89209A8),
    helpstring("LineCodes Object")
  ]
  coclass LineCodes
  {
    [default] interface ILineCodes;
  };

  [
    uuid(D0D4455C-A5CA-4B26-ABB4-2CC3798D260E),
    helpstring("GICSources Object")
  ]
  coclass GICSources
  {
    [default] interface IGICSources;
  };

  [
    uuid(553148EA-97CB-4559-933A-A734250E95C6),
    helpstring("Reduce Object")
  ]
  coclass ReduceCkt
  {
    [default] interface IReduceCkt;
  };

};
